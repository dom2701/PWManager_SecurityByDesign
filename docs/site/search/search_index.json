{"config":{"lang":["de"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Willkommen zur PWManager Dokumentation","text":"<p>Dies ist die technische Dokumentation f\u00fcr das Projekt PWManager SecurityByDesign.</p>"},{"location":"#inhalt","title":"Inhalt","text":"<ul> <li>Projekt\u00fcbersicht: Ziele und Scope des Projekts.</li> <li>Threat Modeling: Analyse der Bedrohungen und Risiken.</li> <li>Security Requirements: Definierte Sicherheitsanforderungen.</li> <li>Implementierung: Details zur Umsetzung und Sicherheitsfeatures.</li> <li>Deployment &amp; CI/CD: Infrastruktur und Automatisierung.</li> <li>K3s Setup: Anleitung zum lokalen Cluster-Setup.</li> <li>Lessons Learned: R\u00fcckblick und Erkenntnisse.</li> </ul>"},{"location":"01_Projekt%C3%BCbersicht/","title":"1. Projekt\u00fcbersicht und Architektur","text":"<p>Diese Seite dient als Einstiegspunkt in diese Projektdokumentation. Sie soll eine kurzen und klaren \u00dcberblick \u00fcber das Projekt und die verwendeten Technologien geben. Au\u00dferdem werden die wichtigsten Security Requirements kurz aufgelistet und das Architektur Diagramm erm\u00f6glicht eine kompakte Darstellung des Projekts.</p>"},{"location":"01_Projekt%C3%BCbersicht/#11-ziel-der-webanwendung","title":"1.1. Ziel der Webanwendung","text":"<p>Ziel dieses Projekts ist die Implementierung eines sichern Online-Passwort-Manager zur zentralen Verwaltung und Verschl\u00fcsselung von Zugangsdaten f\u00fcr Privatpersonen. Das Backend basiert auf Golang und einer SQL-Datenbank, die API-Endpoints und Datenspeicherung bereitstellen. Das Frontend wird mit React und TailwindCSS entwickelt und bietet dadurch eine intuitive, responsive Benutzeroberfl\u00e4che.</p>"},{"location":"01_Projekt%C3%BCbersicht/#12-architektur-schaubild","title":"1.2. Architektur-Schaubild","text":""},{"location":"01_Projekt%C3%BCbersicht/#13-definiert-security-requirements","title":"1.3. Definiert Security Requirements","text":"<ol> <li>Sichere Speicherung von Passw\u00f6rtern und Zugangsdaten</li> <li>Passwort-Generator f\u00fcr starke und zuf\u00e4llige Passw\u00f6rter</li> <li>Automatisches L\u00f6schen der Passw\u00f6rter aus der Zwischenablage</li> <li>Session-Management mit automatischem Timeout (15 Minuten)</li> <li>Audit-Logging aller sicherheitskritischen Aktionen</li> </ol> <p>--&gt; Auf die Security Requirements wird in der SecurityRequirements.md im Detail eingegangen.</p>"},{"location":"01_Projekt%C3%BCbersicht/#14-tech-stack","title":"1.4. Tech-Stack","text":"<p>Dieser Abschnitt beschreibt den f\u00fcr dieses Projekt verwendeten Tech-Stack, untergliedert in Backend, Frontend &amp; Infrastruktur und gibt eine k\u00fcrze Begr\u00fcndung f\u00fcr die getroffene Wahl.</p>"},{"location":"01_Projekt%C3%BCbersicht/#141-backend-technologien","title":"1.4.1. Backend-Technologien","text":"<p>Go (Golang) - Sichere, typsichere Sprache mit performanter Ausf\u00fchrung - Ausgezeichnete Unterst\u00fctzung f\u00fcr Kryptographische Operationen via <code>crypto</code>-Standardbibliothek - Hohe Concurrency-Performance durch Goroutines \u2013 wichtig f\u00fcr gleichzeitige Benutzer-Sessions - Schnelle Kompilierung und einfache Deployment (Single Binary) - Native Support f\u00fcr RESTful APIs mit minimalen Abh\u00e4ngigkeiten</p> <p>PostgreSQL (SQL-Datenbank) - Robuste, vertrauensw\u00fcrdige relationale Datenbank mit starken ACID-Garantien - Ausgezeichnete Sicherheitsfeatures (Row-Level Security, Prepared Statements) - Hohe Integrit\u00e4t f\u00fcr sensitive Benutzer- und Passwort-Daten - Etabliert im produktiven Einsatz seit Jahrzehnten</p> <p>RESTful API - Standardisierte, zustandslose Architektur f\u00fcr sichere Client-Server-Kommunikation - Klare Trennung von Authentifizierung (Cookies) und Business Logic - Einfaches Testing und Monitoring von API-Endpoints - Session-basierte Authentifizierung mit HttpOnly-Cookies f\u00fcr XSS-Pr\u00e4vention</p>"},{"location":"01_Projekt%C3%BCbersicht/#142-frontend-technologien","title":"1.4.2. Frontend-Technologien","text":"<p>React - Automatisches HTML-Escaping in JSX verhindert XSS-Angriffe by default - Component-basierte Architektur erm\u00f6glicht Sicherheits-Patterns einfach umzusetzen - Starke Community und umfangreiche Security-Ressourcen - Virtual DOM erm\u00f6glicht sichere und performante UI-Updates</p> <p>Tailwind CSS - Utility-First Ansatz f\u00fcr schnelle und konsistente UI-Entwicklung - Reduziert Boilerplate-Code und potenzielle CSS-Sicherheitsl\u00fccken - Responsive Design out-of-the-box mit Mobile-First Approach - Einfache Theme-Verwaltung f\u00fcr sichere, konsistente Benutzer-Interfaces</p> <p>Responsive Design - Sichere Passwort-Eingabe auch auf mobilen Ger\u00e4ten mit nativen Eingabefunktionen - Inkonsistente Layouts k\u00f6nnen zu Phishing-Anf\u00e4lligkeit f\u00fchren \u2013 Konsistenz ist ein Sicherheits-Feature - Breite Kompatibilit\u00e4t mit verschiedenen Browsern und Ger\u00e4ten</p>"},{"location":"01_Projekt%C3%BCbersicht/#143-infrastruktur-technologien","title":"1.4.3. Infrastruktur-Technologien","text":"<p>Redis (Session Store) - In-Memory Datenbank f\u00fcr schnelle, sichere Session-Verwaltung - Server-seitige Sessions (nicht im Cookie) \u2013 verhindert Cookie-Tampering - Automatische TTL-Verwaltung f\u00fcr Session-Timeouts - Netzwerk-Isolation: Nicht \u00f6ffentlich exponiert, nur \u00fcber interne Docker-Networks erreichbar</p>"},{"location":"02_ThreatModeling/","title":"2. Komponenten und Sicherheitsanalyse (Threat Modeling)","text":""},{"location":"02_ThreatModeling/#21-komponentenbeschreibung","title":"2.1. Komponentenbeschreibung","text":"<p>Das System folgt einer klassischen Client-Server-Architektur mit einem starken Fokus auf \"Security by Design\" durch clientseitige Verschl\u00fcsselung (Zero-Knowledge-Architektur).</p>"},{"location":"02_ThreatModeling/#211-backend-services","title":"2.1.1. Backend-Services","text":"<p>Das Backend ist als monolithische Go-Anwendung (basierend auf dem Gin-Framework) implementiert, die RESTful APIs bereitstellt. *   API-Layer: Zentraler Einstiegspunkt f\u00fcr alle Anfragen. Implementiert Middleware f\u00fcr Authentifizierung (Session-basiert), CORS-Richtlinien und strukturiertes Logging. *   Auth-Service: Verwaltet Identit\u00e4ten, Registrierung und Anmeldung. Passw\u00f6rter werden serverseitig mittels Argon2id gehasht. Unterst\u00fctzt Multi-Faktor-Authentifizierung (MFA), wobei TOTP-Secrets und Backup-Codes serverseitig verschl\u00fcsselt (AES-GCM) gespeichert werden. *   Vault-Service: Zust\u00e4ndig f\u00fcr die Verwaltung von Tresoren und Passworteintr\u00e4gen. Wichtig: Dieser Service verarbeitet und speichert ausschlie\u00dflich verschl\u00fcsselte Blobs (Ciphertext) und hat keinen Zugriff auf die Klartextdaten oder den Master-Key. *   Audit-Service: Protokolliert sicherheitsrelevante Ereignisse (z.B. Anmeldeversuche, Datenzugriffe) unver\u00e4nderbar in der Datenbank, um Nachvollziehbarkeit zu gew\u00e4hrleisten.</p>"},{"location":"02_ThreatModeling/#212-frontend-komponenten","title":"2.1.2. Frontend-Komponenten","text":"<p>Das Frontend ist eine React-basierte Single Page Application (SPA), die im Browser des Benutzers ausgef\u00fchrt wird. Sie \u00fcbernimmt die kritische Aufgabe der kryptographischen Operationen. *   Crypto-Engine (utils/crypto.js): Kernkomponente f\u00fcr die Sicherheit. F\u00fchrt die Schl\u00fcsselableitung (PBKDF2) aus dem Master-Passwort durch und verschl\u00fcsselt/entschl\u00fcsselt Daten lokal mittels AES-GCM. Das Master-Passwort verl\u00e4sst niemals den Browser-Kontext. *   Session Management: Verwaltet den Authentifizierungsstatus und implementiert Sicherheitsmechanismen wie Auto-Logout bei Inaktivit\u00e4t (AutoLogoutContext). *   UI-Komponenten: Stellt Formulare f\u00fcr Authentifizierung und Tresorverwaltung bereit, wobei sensitive Eingaben (wie das Master-Passwort) isoliert verarbeitet werden.</p>"},{"location":"02_ThreatModeling/#213-infrastruktur-komponenten","title":"2.1.3. Infrastruktur-Komponenten","text":"<p>Die Infrastruktur wird containerisiert (Docker/Kubernetes) betrieben und trennt strikt zwischen Datenhaltung und Verarbeitung. *   Ingress Controller (Traefik): Fungiert als Reverse Proxy und Load Balancer. Er terminiert TLS-Verbindungen und routet Anfragen an Frontend oder Backend. *   PostgreSQL Datenbank: Relationale Datenbank zur persistenten Speicherung von Benutzerdaten (gehasht), verschl\u00fcsselten Tresor-Daten und Audit-Logs. Sie l\u00e4uft in einem isolierten Netzwerksegment. *   Redis Cache: In-Memory Key-Value Store. Wird prim\u00e4r f\u00fcr das schnelle Speichern und Abrufen von Session-Informationen verwendet, um die Zustandsbehaftung des Backends zu minimieren.</p>"},{"location":"02_ThreatModeling/#22-threat-modeling","title":"2.2. Threat Modeling","text":""},{"location":"02_ThreatModeling/#221-systemmodell-mit-data-flow-diagram-dfd","title":"2.2.1. Systemmodell mit Data Flow Diagram (DFD)","text":""},{"location":"02_ThreatModeling/#222-erklarung-der-datenflusse","title":"2.2.2. Erkl\u00e4rung der Datenfl\u00fcsse","text":""},{"location":"02_ThreatModeling/#user-application","title":"User &lt;--&gt; Application","text":"<ol> <li>User sendet verschl\u00fcsselte Anfrage an Traefik.</li> <li>Traefik leitet Anfrage an Frontend Pods weiter.</li> <li>Traefik leitet API-Anfragen an Backend Pods weiter.</li> <li>Frontend Pods liefern statische Assets zur\u00fcck an Traefik.</li> <li>Backend pr\u00fcft G\u00fcltigkeit der Session in Redis. </li> <li>Redis liefert Session-Data zur\u00fcck an das Backend.</li> <li>Backend f\u00fchrt Datenbank-Operationen auf PostgreSQL aus.</li> <li>PostgreSQL liefert Abfrageergebnisse zur\u00fcck an das Backend.</li> <li>Backend sendet API-Antworten an Traeffik zur\u00fcck.</li> <li>Traefik leitet verschl\u00fcsselte Antwort zur\u00fcck an den User.</li> </ol>"},{"location":"02_ThreatModeling/#developer-kubernetes","title":"Developer &lt;--&gt; Kubernetes","text":"<ol> <li>Developer pusht Code-\u00c4nderungen zu GitHub.</li> <li>GitHub benachrichtigt CI/CD \u00fcber neuen Commit.</li> <li>CI/CD erstellt Docker-Images aus dem Code.</li> <li>CI/CD l\u00e4dt Images in Registry hoch.</li> <li>Kubernetes zieht neue Images aus der Registry.</li> <li>CI/CD deployed aktualisierte Pods in Kubernetes.</li> </ol>"},{"location":"02_ThreatModeling/#23-detaillierte-stride-analyse-pro-komponente","title":"2.3. Detaillierte STRIDE-Analyse pro Komponente","text":""},{"location":"02_ThreatModeling/#231-komponente-frontend-spa-react","title":"2.3.1. Komponente: Frontend SPA (React)","text":"STRIDE Bedrohung Beschreibung Beispielangriff Vorraussetzungen Gegenma\u00dfnahmen Status Spoofing Phishing / UI Redressing Angreifer t\u00e4uscht die Benutzeroberfl\u00e4che vor, um das Master-Passwort abzugreifen. Angreifer hostet eine identisch aussehende Seite unter einer \u00e4hnlichen Domain (Typosquatting). Benutzer ruft falsche URL auf. Schulung der Benutzer, Verwendung von Lesezeichen, Browser-Sicherheitsindikatoren (TLS). Extern (User) Tampering Cross-Site Scripting (XSS) Einschleusen von b\u00f6sartigem JavaScript, das im Kontext der Anwendung ausgef\u00fchrt wird. Angreifer speichert ein Skript in einem geteilten Notizfeld, das beim Rendern ausgef\u00fchrt wird und das Master-Passwort aus dem Speicher liest. Schwachstelle im Rendering oder in einer Abh\u00e4ngigkeit (Supply Chain). React Escaping (automatisch), Content Security Policy (CSP), Subresource Integrity (SRI), Regelm\u00e4\u00dfige Dependency-Audits (<code>npm audit</code>). Teilweise (React Default aktiv, CSP/SRI fehlen) Tampering Manipulation des Client-Codes Ver\u00e4nderung des ausgelieferten JavaScript-Bundles (Man-in-the-Middle oder Server-Compromise). Angreifer modifiziert <code>crypto.js</code> w\u00e4hrend der \u00dcbertragung, um eine Hintert\u00fcr einzubauen. Kontrolle \u00fcber Netzwerk oder CDN/Server. HTTPS (TLS), Subresource Integrity (SRI) f\u00fcr externe Skripte. Implementiert (TLS) Information Disclosure Unsichere Speicherung von Secrets Speicherung des Master-Passworts oder abgeleiteter Schl\u00fcssel im LocalStorage/SessionStorage. Malware auf dem PC liest <code>localStorage</code> aus und stiehlt den Key. Physischer Zugriff oder XSS. Secrets nur im fl\u00fcchtigen Speicher (RAM) halten. L\u00f6schen bei Logout/Reload. Implementiert (Memory-only Design) Information Disclosure Leaking via Browser Cache/History Sensible Daten verbleiben im Browser-Cache oder in der URL-History. Master-Passwort wird als URL-Parameter \u00fcbergeben (<code>?pw=...</code>) und landet in der History. Zugriff auf Browser-History. POST-Requests f\u00fcr sensible Daten, <code>Cache-Control: no-store</code> Header, keine sensiblen Daten in URL. Implementiert Denial of Service Client-Side Resource Exhaustion \u00dcberlastung des Browsers durch rechenintensive Operationen. Angreifer manipuliert PBKDF2-Parameter (z.B. 100 Mio. Iterationen), sodass der Browser einfriert. Manipulation der Konfiguration vom Server. Validierung der Krypto-Parameter im Client (Obergrenzen). Offen Elevation of Privilege Cross-Site Request Forgery (CSRF) Angreifer zwingt den Browser des Benutzers zu ungewollten Aktionen im authentifizierten Kontext. Angreifer-Seite sendet POST-Request zum L\u00f6schen eines Tresors. Benutzer ist eingeloggt, keine CSRF-Protection. <code>SameSite=Lax/Strict</code> Cookies, Anti-CSRF Tokens (f\u00fcr State-Changing Operations). Teilweise (<code>SameSite</code> Cookies genutzt) <p>Begr\u00fcndung f\u00fcr nicht/teilweise umgesetzte Ma\u00dfnahmen: *   Denial of Service (Offen): Client-seitige Ressourcenlimits sind schwer durchzusetzen. Der Fokus liegt auf Server-Stabilit\u00e4t. *   Tampering (Teilweise): CSP und SRI sind komplexe Themen, die f\u00fcr das MVP zur\u00fcckgestellt wurden, aber f\u00fcr V2 geplant sind. *   Elevation of Privilege (Teilweise): <code>SameSite=Lax</code> bietet bereits guten Schutz gegen CSRF in modernen Browsern. Vollst\u00e4ndige Token-Validierung erh\u00f6ht die Komplexit\u00e4t signifikant.</p>"},{"location":"02_ThreatModeling/#232-komponente-backend-api-go","title":"2.3.2. Komponente: Backend API (Go)","text":"STRIDE Bedrohung Beschreibung Beispielangriff Vorraussetzungen Gegenma\u00dfnahmen Status Spoofing Service Impersonation Ein b\u00f6sartiger Service gibt sich als Backend-API aus. Angreifer leitet DNS um oder \u00fcbernimmt IP, um Credentials abzufangen. Netzwerk-Kontrolle, fehlende Server-Authentifizierung. TLS-Zertifikate (Server Identity), HSTS. Implementiert Tampering Dependency Confusion / Supply Chain Kompromittierte Go-Module oder Docker-Base-Images. Einschleusen von Schadcode \u00fcber eine manipulierte Library (<code>go.mod</code>). Zugriff auf Public Repos oder Build-Pipeline. Dependency Pinning (<code>go.sum</code>), Vulnerability Scanning (Trivy), Minimal Base Images (Distroless). Teilweise (<code>go.sum</code> vorhanden) Repudiation Insufficient Logging Fehlende Protokollierung von Sicherheitsvorf\u00e4llen verhindert Forensik. Angreifer probiert Passw\u00f6rter durch (Brute Force), ohne dass es bemerkt wird. Logging deaktiviert oder unzureichend. Strukturiertes Audit-Logging (wer, was, wann), zentrales Log-Management. Implementiert (Audit-Service) Information Disclosure Error Handling Leaks Stacktraces oder interne Pfade werden bei Fehlern ausgegeben. API gibt bei DB-Fehler den SQL-Query und Tabellennamen zur\u00fcck. Debug-Modus aktiv, schlechtes Error-Handling. Generische Fehlermeldungen an Client, detaillierte Logs nur intern (Zap Logger). Implementiert Denial of Service Resource Exhaustion \u00dcberlastung von CPU/RAM durch komplexe Anfragen. Angreifer sendet riesige JSON-Payloads oder initiiert viele TLS-Handshakes. Kein Rate Limiting, keine Ressourcen-Limits. Request Size Limits, Timeouts, Rate Limiting (Middleware/Ingress). Offen (Rate Limiting fehlt) Elevation of Privilege Broken Access Control Zugriff auf Ressourcen anderer Benutzer durch ID-Manipulation (IDOR). \u00c4ndern der <code>vault_id</code> in der URL, um fremden Tresor zu lesen. Fehlende Autorisierungspr\u00fcfung im Handler. Strikte Besitzpr\u00fcfung (<code>CheckOwnership</code>) bei jedem Zugriff. Implementiert <p>Begr\u00fcndung f\u00fcr nicht/teilweise umgesetzte Ma\u00dfnahmen: *   Tampering (Teilweise): <code>go.sum</code> verhindert \u00c4nderungen an direkten Abh\u00e4ngigkeiten. Ein vollst\u00e4ndiger Supply-Chain-Schutz (z.B. Sigstore) w\u00fcrde den Rahmen des Projekts sprengen. *   Denial of Service (Offen): Rate Limiting erfordert eine verteilte State-Verwaltung (Redis), was die Komplexit\u00e4t erh\u00f6ht. F\u00fcr das MVP wird das Risiko akzeptiert.</p>"},{"location":"02_ThreatModeling/#233-komponente-postgresql-datenbank","title":"2.3.3. Komponente: PostgreSQL Datenbank","text":"STRIDE Bedrohung Beschreibung Beispielangriff Vorraussetzungen Gegenma\u00dfnahmen Status Spoofing Unauthorized Access Zugriff auf DB ohne g\u00fcltige Credentials. Angreifer verbindet sich direkt mit Port 5432. DB-Port \u00f6ffentlich exponiert, schwaches Passwort. DB im privaten Subnetz, Zugriff nur via Backend erlaubt (Network Policies), starke Passw\u00f6rter. Implementiert (Docker Network) Tampering Data Corruption L\u00f6schen oder Ver\u00e4ndern von Daten durch Malware oder Fehlkonfiguration. Ransomware verschl\u00fcsselt DB-Files. Zugriff auf Filesystem oder DB-Admin-Rechte. Regelm\u00e4\u00dfige Backups, Least Privilege f\u00fcr DB-User. Offen (Backup-Strategie fehlt) Repudiation Admin Activity Hiding DB-Admin manipuliert Daten und l\u00f6scht Spuren. Admin l\u00f6scht User-Tabelle und deaktiviert Logging. Admin-Rechte auf DB. Remote Logging (Logs an separaten Server senden), 4-Augen-Prinzip. Akzeptiert (Vertrauen in Admin) Information Disclosure Data Theft at Rest Diebstahl der Datenbank-Dateien oder Backups. Angreifer kopiert Volume-Daten vom Host. Zugriff auf Host-System. Encryption at Rest (Filesystem-Level oder DB-Level), Zero-Knowledge (Daten sind eh verschl\u00fcsselt). Implementiert (Zero-Knowledge) Denial of Service Connection Exhaustion \u00dcberlasten der DB Backend \u00f6ffnet zu viele Connections ohne sie zu schlie\u00dfen (Leak). Schlechtes Connection Pooling. Connection Pooling (in <code>sqlx</code> konfiguriert), Max Connections Limit. Implementiert Elevation of Privilege Privilege Escalation Ausnutzen von DB-Schwachstellen f\u00fcr Host-Zugriff. Exploit in Postgres-Funktion erlaubt Shell-Execution. Ungepatchte DB-Version. Regelm\u00e4\u00dfige Updates, Container als Non-Root User ausf\u00fchren. Implementiert (Docker Best Practices) <p>Begr\u00fcndung f\u00fcr nicht/teilweise umgesetzte Ma\u00dfnahmen: *   Tampering (Offen): Eine umfassende Backup-Strategie (Offsite-Backups, Restore-Tests) ist operativ aufwendig und f\u00fcr die Entwicklungsumgebung nicht priorisiert. *   Repudiation (Akzeptiert): Das Risiko, dass ein Datenbank-Administrator Logs manipuliert, wird akzeptiert, da dieser ohnehin vollen Zugriff auf die Infrastruktur hat (\"Trusted Admin\").</p>"},{"location":"02_ThreatModeling/#234-komponente-redis-cache","title":"2.3.4. Komponente: Redis Cache","text":"STRIDE Bedrohung Beschreibung Beispielangriff Vorraussetzungen Gegenma\u00dfnahmen Status Spoofing Unauthorized Access Zugriff auf Redis ohne Authentifizierung. Angreifer liest alle Session-Keys aus. Redis oft standardm\u00e4\u00dfig ohne Passwort (\"Protected Mode\" aus), Port offen. Redis Passwort setzen (<code>requirepass</code>), Network Isolation. Implementiert Tampering Session Manipulation Ver\u00e4ndern von Session-Daten (z.B. <code>user_id</code> \u00e4ndern). Angreifer \u00e4ndert seine Session, um Admin zu werden. Schreibzugriff auf Redis. Redis Auth, Integrit\u00e4tsschutz (schwer in Redis, daher Zugriffsschutz priorisieren). Implementiert (Zugriffsschutz) Repudiation Lack of Audit Trail \u00c4nderungen im Cache werden nicht protokolliert. Angreifer l\u00f6scht Sessions anderer User (DoS), keine Spur. Zugriff auf Redis. Redis Monitor (Performance-Impact!), Zugriffsschutz priorisieren. Akzeptiert (Network Isolation + starkes PW) Information Disclosure Session Leakage Auslesen aller aktiven Sessions. Angreifer dumpt Keyspace. Lesezugriff auf Redis. TLS f\u00fcr Redis-Traffic (optional), Zugriffsschutz. Implementiert (Zugriffsschutz) Denial of Service Memory Exhaustion F\u00fcllen des Speichers, bis Redis abst\u00fcrzt (OOM). Erzeugen von Millionen Fake-Sessions. Keine Eviction Policy, kein Memory Limit. <code>maxmemory</code> Limit konfigurieren, <code>allkeys-lru</code> Eviction Policy. Offen Elevation of Privilege Container Escape Ausbruch aus dem Redis-Container auf den Host. Exploit in Redis Lua Engine. Ungepatchte Version, Container als Root. Non-Root User, Seccomp Profile, Updates. Implementiert (Docker) <p>Begr\u00fcndung f\u00fcr nicht/teilweise umgesetzte Ma\u00dfnahmen: *   Repudiation (Akzeptiert): Redis ist ein fl\u00fcchtiger Speicher. Ein Audit-Trail f\u00fcr jeden Cache-Zugriff w\u00fcrde die Performance massiv beeintr\u00e4chtigen. *   Denial of Service (Offen): Eine strikte Memory-Eviction-Policy muss sorgf\u00e4ltig konfiguriert werden, um keine validen Sessions zu l\u00f6schen. Dies erfordert Lasttests.</p>"},{"location":"02_ThreatModeling/#235-datenfluss-user-frontend-input","title":"2.3.5. Datenfluss: User -&gt; Frontend (Input)","text":"STRIDE Bedrohung Beschreibung Beispielangriff Vorraussetzungen Gegenma\u00dfnahmen Status Spoofing Impersonation Unbefugte Nutzung eines unbeaufsichtigten Ger\u00e4ts. Kollege nutzt offenen Laptop, w\u00e4hrend User Kaffee holt. Physischer Zugriff, Session noch aktiv. Kurze Session-Timeouts, Auto-Logout bei Inaktivit\u00e4t. Implementiert (AutoLogoutContext) Tampering Keylogging Aufzeichnen der Tastatureingaben (Master-Passwort). Hardware-Keylogger oder Malware auf Client-PC. Kompromittiertes Endger\u00e4t. Virtuelle Tastatur (begrenzt hilfreich), 2FA/MFA (sch\u00fctzt vor Login auf neuem Ger\u00e4t, aber nicht vor lokaler Session-\u00dcbernahme). Implementiert (MFA) Repudiation Bestreiten von UI-Interaktionen Benutzer f\u00fchrt eine Aktion aus und behauptet sp\u00e4ter, dies nicht getan zu haben. \"Ich habe den 'L\u00f6schen'-Button nicht geklickt, der Eintrag ist einfach verschwunden.\" Fehlende Best\u00e4tigungsdialoge. Erzwungene Best\u00e4tigung bei kritischen Aktionen (Modal/Popup), Korrelation mit Backend-Audit-Logs. Implementiert (UI-Modals) Information Disclosure Shoulder Surfing Beobachten der Passworteingabe. Person schaut \u00fcber die Schulter. Physische N\u00e4he. Passwort-Feld maskieren (<code>type=\"password\"</code>), Sichtschutzfolien (User-Verantwortung). Implementiert (UI) Denial of Service Input Blocking Malware blockiert Eingabefelder oder \u00fcberlagert UI. Overlay-Attacke verhindert Login. Malware auf Client. Antivirus, OS-Sicherheitsmechanismen. Extern (User Device) Elevation of Privilege Accessibility Abuse Malware nutzt A11y-APIs um Rechte zu erlangen/Daten zu lesen. Screenreader-Malware liest Passwort-Feld. Malware auf Client. OS-Permissions pr\u00fcfen (Mobile), schwer im Web zu verhindern. Akzeptiert <p>Begr\u00fcndung f\u00fcr nicht/teilweise umgesetzte Ma\u00dfnahmen: *   Denial of Service (Extern): Gegen Malware auf dem Endger\u00e4t des Benutzers kann die Webanwendung technisch nichts ausrichten. *   Elevation of Privilege (Akzeptiert): Accessibility-APIs sind notwendig f\u00fcr Barrierefreiheit. Missbrauch durch Malware auf dem Client liegt au\u00dferhalb der Kontrolle der Webanwendung.</p>"},{"location":"02_ThreatModeling/#236-datenfluss-frontend-backend-https","title":"2.3.6. Datenfluss: Frontend -&gt; Backend (HTTPS)","text":"STRIDE Bedrohung Beschreibung Beispielangriff Vorraussetzungen Gegenma\u00dfnahmen Status Spoofing Man-in-the-Middle (MitM) Angreifer klinkt sich in Verbindung ein. ARP-Spoofing im \u00f6ffentlichen WLAN. Fehlende oder schwache Verschl\u00fcsselung. TLS 1.2/1.3 erzwingen, Starke Cipher-Suites. Implementiert Tampering Replay Attack Wiederholtes Senden einer abgefangenen (verschl\u00fcsselten) Anfrage. Angreifer f\u00e4ngt \"Create Vault\"-Request ab und sendet ihn erneut. Keine Replay-Protection (Nonces/Timestamps). TLS (verhindert Replay auf Netzwerkebene), Nonces in API-Design (optional). Implementiert (TLS) Repudiation Bestreiten der Urheberschaft Ein Benutzer bestreitet, einen bestimmten API-Request (z.B. \"L\u00f6sche Tresor\") gesendet zu haben. Angreifer nutzt gestohlene Session-ID, um Requests zu senden; Opfer behauptet glaubhaft, es nicht gewesen zu sein. Session-Hijacking m\u00f6glich. IP-Logging, User-Agent Logging, kurze Session-Lifetimes. Akzeptiert (Risiko durch Session-Schutz minimiert) Information Disclosure Traffic Sniffing Mitlesen von sensiblen Daten (Session-Cookie, Ciphertext). Wireshark im unverschl\u00fcsselten Netz. Kein HTTPS. HTTPS Everywhere, HSTS, Secure Cookies. Implementiert Denial of Service Flooding / DDoS \u00dcberfluten der Application. Volumetrische Angriffe auf den Ingress. Ausreichende Bandbreite beim Angreifer. Upstream DDoS Protection (Cloudflare, AWS Shield). Extern (Infrastruktur) Elevation of Privilege Parameter Tampering Manipulation von Parametern im Transit. \u00c4ndern von <code>{\"role\": \"user\"}</code> zu <code>{\"role\": \"admin\"}</code> im Body. Kein Integrit\u00e4tsschutz (TLS fehlt). TLS (Integrit\u00e4t), Serverseitige Validierung. Implementiert <p>Begr\u00fcndung f\u00fcr nicht/teilweise umgesetzte Ma\u00dfnahmen: *   Repudiation (Akzeptiert): Client-Zertifikate (mTLS) sind f\u00fcr Endanwender-Anwendungen unpraktikabel (UX). Das Risiko wird durch andere Auth-Mechanismen mitigiert. *   Denial of Service (Extern): DDoS-Schutz ist Aufgabe der Infrastruktur (Provider), nicht der Applikationslogik.</p>"},{"location":"02_ThreatModeling/#237-datenfluss-backend-postgresql-sql","title":"2.3.7. Datenfluss: Backend -&gt; PostgreSQL (SQL)","text":"STRIDE Bedrohung Beschreibung Beispielangriff Vorraussetzungen Gegenma\u00dfnahmen Status Spoofing Connection Spoofing Angreifer verbindet sich als Backend zur DB. IP-Spoofing im internen Netz. Schwache Netzwerkkontrollen. mTLS zwischen App und DB, Passwort-Auth. Implementiert (Passwort) Tampering SQL Injection Manipulation der SQL-Query durch User-Input. Eingabe von <code>' OR 1=1; --</code> im Login-Feld. Unsichere String-Konkatenation im Code. Prepared Statements / Parameterized Queries (<code>sqlx</code>). Implementiert Repudiation Transaction Denial DB oder App leugnen Transaktion. Inkonsistenz zwischen App-Log und DB-Daten. Fehlende Transaktionslogs. WAL (Write Ahead Log) in Postgres, App-Audit-Logs. Implementiert Information Disclosure Logging of Sensitive Data SQL-Queries mit Parametern landen im Log. DB-Log enth\u00e4lt Klartext-Daten (hier nur Ciphertext/Hashes, aber trotzdem unsch\u00f6n). Logging-Level zu hoch (Debug). Logging konfigurieren (keine Parameter loggen), Zero-Knowledge (Daten sind eh verschl\u00fcsselt). Implementiert Denial of Service Slow Queries Ausf\u00fchren extrem aufwendiger Queries. Angreifer triggert Suche, die Full-Table-Scan ausl\u00f6st. Fehlende Indizes. DB-Indizes auf Fremdschl\u00fcsseln und Suchfeldern setzen. Teilweise Elevation of Privilege SQL Injection (EoP) Nutzung von SQLi zur Rechteausweitung. <code>UNION SELECT</code> um Admin-Passwort-Hash zu lesen. SQLi-L\u00fccke. Prepared Statements. Implementiert <p>Begr\u00fcndung f\u00fcr nicht/teilweise umgesetzte Ma\u00dfnahmen: *   Denial of Service (Teilweise): Datenbank-Indizes sind gesetzt, aber eine umfassende Query-Optimierung und Timeouts f\u00fcr alle m\u00f6glichen Queries fehlen noch.</p>"},{"location":"02_ThreatModeling/#238-datenfluss-backend-redis-internal","title":"2.3.8. Datenfluss: Backend -&gt; Redis (Internal)","text":"STRIDE Bedrohung Beschreibung Beispielangriff Vorraussetzungen Gegenma\u00dfnahmen Status Spoofing Internal MitM Abfangen der Verbindung im Container-Netzwerk. Kompromittierter Nachbar-Container sniffed Traffic. Flaches Netzwerk, ARP-Spoofing m\u00f6glich. TLS f\u00fcr Redis (oft Overhead), Network Policies (Isolation). Teilweise (Isolation) Tampering Command Injection Einschleusen von Redis-Befehlen. CRLF Injection wenn Input ungefiltert an Redis geht. Unsichere Redis-Library Nutzung. Nutzung typsicherer Redis-Clients (go-redis). Implementiert Repudiation No Audit Keine Logs \u00fcber Cache-Zugriffe. Siehe oben. - - Akzeptiert Information Disclosure Unencrypted Transport Session-IDs werden im Klartext \u00fcbertragen (intern). Siehe oben. Kein TLS intern. Risikoakzeptanz im privaten Cluster-Netzwerk oder mTLS (Service Mesh). Akzeptiert Denial of Service Connection Flooding \u00dcberlastung der Redis-Verbindungen. Loop \u00f6ffnet tausende Connections. Bug oder Angriff. Connection Pooling, Max Clients Limit. Implementiert Elevation of Privilege Lua Sandbox Escape Ausbruch aus Redis via Lua. B\u00f6sartiges Lua-Skript. <code>EVAL</code> Rechte f\u00fcr User. <code>EVAL</code> deaktivieren oder einschr\u00e4nken (rename-command). Offen <p>Begr\u00fcndung f\u00fcr nicht/teilweise umgesetzte Ma\u00dfnahmen: *   Spoofing (Teilweise): Im internen Docker-Netzwerk wird auf strikte Netzwerk-Isolation vertraut. TLS f\u00fcr Redis-Traffic ist ein Performance-Tradeoff. *   Repudiation (Akzeptiert): Siehe Redis-Komponente oben (Performance). *   Information Disclosure (Akzeptiert): Siehe Spoofing. Vertrauen in die Isolation des Container-Netzwerks. *   Elevation of Privilege (Offen): Das H\u00e4rten der Redis-Konfiguration (Deaktivieren gef\u00e4hrlicher Befehle) steht noch aus.</p>"},{"location":"02_ThreatModeling/#24-attack-tree-worst-case-compromise-backend","title":"2.4. Attack Tree (Worst Case: \"Compromise Backend\")","text":"<p>Das Szenario betrachtet den Fall, dass ein Angreifer volle Kontrolle \u00fcber den Backend-Container erlangt (z.B. durch RCE).</p> <p>Ziel: Entschl\u00fcsselung der Tresore aller Benutzer.</p> <p>Der Attack Tree ist aufgrund Darstellungsproblemen unter https://github.com/user-attachments/assets/d645b8ad-3c56-4a53-8cce-1fc076d731fe zu finden.</p>"},{"location":"02_ThreatModeling/#241-branch-details","title":"2.4.1. Branch-Details","text":"<p>Hier werden die Gegenma\u00dfnahmen gegen die Bedrohungen der einzelnen Branches im Detail beschrieben.</p>"},{"location":"02_ThreatModeling/#2411-branch-1-master-password-stealing","title":"2.4.1.1. Branch 1: Master Password Stealing","text":""},{"location":"02_ThreatModeling/#24111-xss-angriff-zur-extraktion-des-master-passworts","title":"2.4.1.1.1. XSS-Angriff zur Extraktion des Master-Passworts","text":"<p>Bedrohung: Ein Angreifer injiziert b\u00f6sartigen JavaScript-Code, um das Master-Passwort abzufangen, das der Benutzer eingibt.</p> <p>Gegenma\u00dfnahme:  - Das Frontend nutzt React, das standardm\u00e4\u00dfig HTML-Escaping f\u00fcr JSX-Content durchf\u00fchrt - Benutzer-Input wird durch React automatisch escaped, bevor er gerendert wird - Keine direkten <code>innerHTML</code> oder <code>dangerouslySetInnerHTML</code>-Operationen f\u00fcr Benutzerdaten - Das Passwort-Eingabefeld verwendet <code>type=\"password\"</code> mit nativen Browser-Schutzfunktionen - Das Passwort wird sofort nach Eingabe client-seitig mit PBKDF2 deriviert und der Klartext wird nicht persistent gespeichert</p>"},{"location":"02_ThreatModeling/#24112-keylogger-auf-user-gerat-installiert","title":"2.4.1.1.2. Keylogger auf User-Ger\u00e4t installiert","text":"<p>Bedrohung: Malware auf dem Client-Ger\u00e4t erfasst das Master-Passwort w\u00e4hrend der Eingabe.</p> <p>Gegenma\u00dfnahme: - Das Master-Passwort wird nur lokal verarbeitet und verl\u00e4sst das Client-Ger\u00e4t nie im Klartext - Das Passwort-Eingabefeld nutzt HTML5 <code>type=\"password\"</code>, das vom Browser vor vielen Angriffsformen sch\u00fctzt - Die PBKDF2-Derivation erfolgt sofort nach Eingabe in <code>frontend/src/handlers/authHandlers.ts</code> - Der Klartext wird nicht persistent gespeichert; nur der abgeleitete Schl\u00fcssel wird zum Server \u00fcbertragen - Selbst wenn ein Keylogger das Passwort abf\u00e4ngt, m\u00fcsste der Angreifer zus\u00e4tzlich die PBKDF2-Derivation (100.000 Iterationen) durchf\u00fchren</p>"},{"location":"02_ThreatModeling/#24113-phishing-zur-erkennung-des-master-passworts","title":"2.4.1.1.3. Phishing zur Erkennung des Master-Passworts","text":"<p>Bedrohung: Ein Angreifer erstellt eine gef\u00e4lschte Kopie der Anwendung und leitet Benutzer dorthin, um das Master-Passwort zu stehlen.</p> <p>Gegenma\u00dfnahme: - Die Anwendung ist f\u00fcr HTTPS/TLS konfiguriert in <code>backend/internal/config/config.go</code> - TLS kann aktiviert werden mit Zertifikat-Pfaden: <code>c.TLS.Enabled</code>, <code>c.TLS.CertPath</code>, <code>c.TLS.KeyPath</code> - Ein g\u00fcltiges SSL/TLS-Zertifikat von einer vertrauensw\u00fcrdigen Zertifizierungsstelle muss installiert sein - HTTP-&gt;HTTPS-Redirect wird implementiert, um Benutzer zu sicheren Verbindungen zu leiten - Der HSTS-Header kann gesetzt werden, um Browser zu zwingen, nur HTTPS-Verbindungen zu verwenden</p>"},{"location":"02_ThreatModeling/#2412-branch-2-session-hijacking","title":"2.4.1.2. Branch 2: Session Hijacking","text":""},{"location":"02_ThreatModeling/#24121-csrf-attacke-cross-site-request-forgery","title":"2.4.1.2.1. CSRF-Attacke (Cross-Site Request Forgery)","text":"<p>Bedrohung: Ein Angreifer verleitet einen authentifizierten Benutzer, eine b\u00f6se Website zu besuchen, die versteckte Anfragen an die API sendet.</p> <p>Gegenma\u00dfnahme: - CORS-Konfiguration mit Origin-Whitelist wird eingesetzt - Nur Anfragen von konfigurierten Origins werden akzeptiert: <code>Access-Control-Allow-Origin</code> wird restriktiv gesetzt - <code>Access-Control-Allow-Credentials: true</code> wird nur bei authentifizierten Requests gesetzt - <code>Access-Control-Allow-Methods</code> wird auf notwendige HTTP-Verben beschr\u00e4nkt (POST, PUT, DELETE, GET) - Anfragen von unerwarteten Origins werden blockiert</p>"},{"location":"02_ThreatModeling/#24122-session-cookie-theft","title":"2.4.1.2.2. Session-Cookie-Theft","text":"<p>Bedrohung: Ein Angreifer stiehlt die Session-Cookie eines Benutzers (z.B. durch XSS oder MITM) und verwendet sie, um sich auszugeben.</p> <p>Gegenma\u00dfnahme: - Session-Cookies werden mit <code>HttpOnly</code>-Flag gesetzt, wodurch JavaScript nicht auf die Cookie zugreift (XSS-Pr\u00e4vention) - Session-Cookies werden mit <code>Secure</code>-Flag gesetzt, das nur HTTPS-\u00dcbertragung erlaubt - Session-IDs werden kryptographisch sicher generiert  - Sessions werden server-seitig in Redis gespeichert (nicht im Cookie) - Session-IDs haben automatische Timeouts und werden nach Inaktivit\u00e4t gel\u00f6scht - Beim Laden von Sessions wird ein Validierungsmechanismus durchgef\u00fchrt</p>"},{"location":"02_ThreatModeling/#24123-man-in-the-middle-mitm-auf-https","title":"2.4.1.2.3. Man-in-the-Middle (MITM) auf HTTPS","text":"<p>Bedrohung: Ein Angreifer auf dem Netzwerk versucht, HTTPS-Verbindungen zu manipulieren oder abzufangen.</p> <p>Gegenma\u00dfnahme: - Die Anwendung erzwingt HTTPS/TLS f\u00fcr alle sensitiven Daten\u00fcbertragungen - Ein g\u00fcltiges SSL/TLS-Zertifikat von einer vertrauensw\u00fcrdigen Zertifizierungsstelle ist erforderlich - Das Backend unterst\u00fctzt TLS 1.2+ Konfiguration - HTTP-&gt;HTTPS-Redirect wird durchgef\u00fchrt (301 oder 308), um Benutzer zu sicheren Verbindungen zu leiten - Session-Cookies haben das <code>Secure</code>-Flag, das nur HTTPS-\u00dcbertragung erlaubt - Alle sensitive Daten (Passw\u00f6rter, Session-Token) werden nur \u00fcber verschl\u00fcsselte Verbindungen \u00fcbertragen</p>"},{"location":"02_ThreatModeling/#2413-branch-3-database-breach","title":"2.4.1.3. Branch 3: Database Breach","text":""},{"location":"02_ThreatModeling/#24131-sql-injection-auf-die-backend-api","title":"2.4.1.3.1. SQL-Injection auf die Backend-API","text":"<p>Bedrohung: Ein Angreifer injiziert SQL-Code \u00fcber API-Parameter, um die Datenbank zu kompromittieren.</p> <p>Gegenma\u00dfnahme: - Durchgehend werden parameterisierte Queries mit dem <code>sqlx</code>-Framework verwendet - Benutzer-Input wird nie direkt in SQL-Strings konkateniert - sqlx f\u00fchrt automatisch Escaping durch und validiert Eingaben - Dies verhindert SQL-Injection-Angriffe vollst\u00e4ndig</p>"},{"location":"02_ThreatModeling/#24132-direkter-zugriff-auf-postgresql-datenbank","title":"2.4.1.3.2. Direkter Zugriff auf PostgreSQL-Datenbank","text":"<p>Bedrohung: Ein Angreifer erh\u00e4lt direkten Zugriff auf PostgreSQL (Port 5432) und kann beliebige SQL-Befehle ausf\u00fchren.</p> <p>Gegenma\u00dfnahme: - PostgreSQL ist in Docker/Kubernetes nur \u00fcber interne Netzwerke erreichbar, nicht \u00f6ffentlich exponiert - In <code>docker-compose.backend.yml</code> ist PostgreSQL nur im internen Netzwerk konfiguriert - Datenbankzugriffe erfolgen ausschlie\u00dflich \u00fcber die Anwendung - Die Datenbankverbindung wird von der Anwendung verwaltet - Datenbank-Credentials werden nicht im Code gespeichert, sondern \u00fcber Environment-Variablen injiziert - Alle Datenbankzugriffe erfolgen \u00fcber authentifizierte API-Endpoints mit Session-Validierung - Benutzer k\u00f6nnen nur ihre eigenen Vaults und Eintr\u00e4ge abrufen</p>"},{"location":"02_ThreatModeling/#24133-redis-session-cache-bruch","title":"2.4.1.3.3. Redis-Session-Cache-Bruch","text":"<p>Bedrohung: Ein Angreifer erh\u00e4lt Zugriff auf Redis und kann Session-Daten manipulieren oder stehlen.</p> <p>Gegenma\u00dfnahme: - Redis ist in Docker/Kubernetes nur \u00fcber interne Netzwerke erreichbar, nicht \u00f6ffentlich exponiert - Redis ist nicht auf der \u00f6ffentlichen IP-Adresse konfiguriert - Session-Daten werden server-seitig in Redis gespeichert, aber Session-IDs sind kryptographisch sicher und nicht vorhersehbar - Sessions haben automatische TTL (Time-To-Live) und Timeouts - Session-IDs k\u00f6nnen nicht einfach manipuliert werden, da sie nur als zuf\u00e4llige Referenzen gespeichert werden - Die Session-ID ist nur eine zuf\u00e4llige 256-Bit-Zahl, die auf Server-Seite validiert wird</p>"},{"location":"02_ThreatModeling/#2414-branch-4-supply-chain-attack","title":"2.4.1.4. Branch 4: Supply Chain Attack","text":""},{"location":"02_ThreatModeling/#24141-dependency-poisoning","title":"2.4.1.4.1. Dependency-Poisoning","text":"<p>Bedrohung: Ein Angreifer kompromittiert eine Dependency, die das Projekt verwendet, mit b\u00f6sartigem Code.</p> <p>Gegenma\u00dfnahme: - Go: <code>go.mod</code> und <code>go.sum</code> sind versionskontrolliert   - <code>go.sum</code> enth\u00e4lt automatisch Checksummen f\u00fcr alle Dependencies   - Genau spezifizierte Versionen werden verwendet (keine <code>^</code> oder <code>~</code>) - npm: <code>package-lock.json</code> ist versionskontrolliert   - <code>package-lock.json</code> enth\u00e4lt Integrit\u00e4t-Checksummen f\u00fcr alle Dependencies - Dependencies werden nur aus vertrauensw\u00fcrdigen Quellen bezogen (pkg.go.dev, npm.org, Maven Central) - \u00c4nderungen an Checksummen in <code>go.sum</code> oder <code>package-lock.json</code> werden sofort bemerkt</p>"},{"location":"02_ThreatModeling/#24142-kompromittiertes-docker-base-image","title":"2.4.1.4.2. Kompromittiertes Docker-Base-Image","text":"<p>Bedrohung: Das Docker-Base-Image enth\u00e4lt Malware, Backdoors oder Anf\u00e4lligkeit.</p> <p>Implementierte Gegenma\u00dfnahme: - Base-Images werden nur von vertrauensw\u00fcrdigen Quellen bezogen (Docker Hub Official Images) - In <code>backend/Dockerfile</code> und <code>frontend/Dockerfile</code> werden spezifische Image-Versionen verwendet, nicht <code>latest</code> - Beispiele aus den Dockerfiles:   - Backend: Go Official Image mit spezifischer Version (z.B. <code>golang:1.21</code>)   - Frontend: Node Official Image mit spezifischer Version (z.B. <code>node:20</code>) - Minimale Base-Images reduzieren die Attack-Surface - Secrets werden nicht im Dockerfile oder Image eingebunden, sondern \u00fcber Environment-Variablen injiziert - Nur notwendige Dependencies werden installiert (keine zus\u00e4tzliche Software)</p> <p>Fazit: Durch das Zero-Knowledge-Design ist das Backend selbst kein \"Single Point of Failure\" f\u00fcr die Vertraulichkeit der gespeicherten Daten, solange der Client-Code vertrauensw\u00fcrdig bleibt. Der kritische Pfad verlagert sich auf die Integrit\u00e4t der Frontend-Auslieferung (Supply Chain Attack).</p>"},{"location":"03_Implementierung%20%26%20Anwendungs%E2%80%90Sicherheit/","title":"3. Implementierung und Anwendungs-Sicherheit","text":""},{"location":"03_Implementierung%20%26%20Anwendungs%E2%80%90Sicherheit/#31-erklarung-der-anwendung-mit-allen-sicherheitsfeatures","title":"3.1. Erkl\u00e4rung der Anwendung mit allen Sicherheitsfeatures","text":""},{"location":"03_Implementierung%20%26%20Anwendungs%E2%80%90Sicherheit/#311-backend-secure-coding-app-security","title":"3.1.1. Backend \u2013 Secure Coding &amp; App-Security","text":""},{"location":"03_Implementierung%20%26%20Anwendungs%E2%80%90Sicherheit/#3111-authentifizierung-und-autorisierung","title":"3.1.1.1. Authentifizierung und Autorisierung","text":"<ul> <li> <p>3.1.1.1.1. Implementierung der g\u00fcltigen Anmeldung     Der Anmeldeprozess wird im <code>AuthHandler.Login</code> gesteuert. Zun\u00e4chst wird die Existenz des Benutzers \u00fcber <code>userRepo.GetByEmail</code> gepr\u00fcft. Um \"User Enumeration\" zu verhindern, wird bei nicht vorhandenem Benutzer lediglich ein interner Audit-Log (<code>user_not_found</code>) erstellt, dem Client jedoch eine generische Fehlermeldung zur\u00fcckgegeben.     Die Passwort\u00fcberpr\u00fcfung erfolgt mittels Argon2id (<code>crypto.VerifyPassword</code>). Erst nach erfolgreicher Validierung des prim\u00e4ren Faktors wird der Status der Multi-Faktor-Authentifizierung (MFA) gepr\u00fcft.     Bei erfolgreicher Authentifizierung generiert der <code>SessionManager</code> mittels <code>crypto/rand</code> eine kryptografisch sichere Session-ID. Diese wird zusammen mit Metadaten (User-ID, Erstellungszeitpunkt, Last-Seen) in einem Redis-Store (Hash-Map) abgelegt. Die Session-ID wird anschlie\u00dfend als <code>HttpOnly</code>-Cookie an den Client \u00fcbermittelt.</p> </li> <li> <p>3.1.1.1.2. Autorisierungsstrategie (RBAC, ABAC)     Die Anwendung implementiert eine strikte Resource-Based Access Control.</p> <ul> <li>Authentifizierung: Die <code>AuthMiddleware</code> extrahiert die Session-ID aus dem Cookie und validiert deren Existenz und G\u00fcltigkeit (Timeout) direkt gegen den Redis-Store (<code>sessionManager.GetSession</code>).</li> <li>Autorisierung: In den Handlern (z.B. <code>VaultHandler</code>, <code>EntryHandler</code>) findet eine explizite Besitzpr\u00fcfung statt. Methoden wie <code>vaultRepo.CheckOwnership</code> stellen sicher, dass Operationen nur auf Ressourcen ausgef\u00fchrt werden k\u00f6nnen, die der authentifizierten <code>UserID</code> zugeordnet sind. Es existieren keine globalen Admin-Rollen oder privilegierten Zugriffe im Applikationscode (\"Least Privilege\").</li> </ul> </li> <li> <p>3.1.1.1.3. Umsetzung von MFA     Die Zwei-Faktor-Authentifizierung basiert auf dem TOTP-Standard (Time-based One-Time Password) und nutzt die Bibliothek <code>github.com/pquerna/otp</code>.</p> <ul> <li>Speicherung: Das TOTP-Secret wird bei der Einrichtung generiert und verschl\u00fcsselt (AES-GCM) in der Datenbanktabelle <code>mfa_secrets</code> abgelegt.</li> <li>Verifizierung: Bei der Anmeldung entschl\u00fcsselt das Backend das Secret tempor\u00e4r im Arbeitsspeicher unter Verwendung des <code>MasterEncryptionKey</code> und validiert den vom Benutzer eingegebenen 6-stelligen Code mittels <code>totp.Validate</code>.</li> </ul> </li> </ul>"},{"location":"03_Implementierung%20%26%20Anwendungs%E2%80%90Sicherheit/#3112-daten-und-protokollsicherheit","title":"3.1.1.2. Daten- und Protokollsicherheit","text":"<ul> <li> <p>3.1.1.2.1. TLS-Readiness     Der Go-Server ist f\u00fcr native TLS-Terminierung vorbereitet. In der <code>main.go</code> wird die Konfiguration <code>TLS.Enabled</code> ausgewertet. Ist diese aktiv, startet der <code>http.Server</code> mittels <code>ListenAndServeTLS</code> und l\u00e4dt das Zertifikat sowie den privaten Schl\u00fcssel von den konfigurierten Pfaden (<code>CertPath</code>, <code>KeyPath</code>). Dies erlaubt den sicheren Betrieb auch ohne vorgeschalteten Reverse-Proxy.</p> </li> <li> <p>3.1.1.2.2. Eingabevalidierung und Schutz vor Injections</p> <ul> <li>Deklarative Validierung: Das <code>gin</code>-Framework nutzt Struct-Tags f\u00fcr die Validierung eingehender JSON-Payloads. Beispiele sind <code>binding:\"required,email\"</code> f\u00fcr E-Mail-Adressen oder <code>min=12,max=128</code> f\u00fcr Passw\u00f6rter.</li> <li>Typsicherheit &amp; Formatpr\u00fcfung: Kritische Parameter wie kryptografische Salts oder Nonces werden explizit auf ihr Hex-Format und die korrekte Byte-L\u00e4nge gepr\u00fcft (z.B. 32 Bytes f\u00fcr Salts, 12 Bytes f\u00fcr Nonces), bevor sie verarbeitet werden.</li> <li>SQL-Injection Schutz: Die Datenbankinteraktion erfolgt \u00fcber die Bibliothek <code>sqlx</code>. Alle SQL-Abfragen nutzen parametrisierte Queries (Prepared Statements mit <code>$1</code>, <code>$2</code> Platzhaltern), wodurch SQL-Injection systembedingt ausgeschlossen wird.</li> </ul> </li> <li> <p>3.1.1.2.3. Kryptografie     Die Anwendung setzt auf moderne, von der Industrie anerkannte Algorithmen:</p> <ul> <li>Passwort-Hashing: Benutzerpassw\u00f6rter werden ausschlie\u00dflich als Argon2id-Hashes gespeichert. Die Parameter sind konservativ gew\u00e4hlt: 64 MB Memory, 3 Iterationen, 4 Parallelism Threads, 16 Byte Salt.</li> <li>Serverseitige Verschl\u00fcsselung: Sensible Systemdaten (wie MFA-Secrets) werden mit AES-GCM (256-Bit Key) verschl\u00fcsselt.</li> <li>Clientseitige Verschl\u00fcsselung (Zero-Knowledge): Tresor-Eintr\u00e4ge werden bereits im Browser verschl\u00fcsselt. Hierf\u00fcr wird aus dem Master-Passwort und dem Vault-Salt mittels PBKDF2 (SHA-256, 600.000 Iterationen) ein Schl\u00fcssel abgeleitet. Die eigentliche Datenverschl\u00fcsselung erfolgt ebenfalls via AES-GCM. Das Backend speichert nur die verschl\u00fcsselten Blobs (<code>EncryptedData</code>) und Nonces.</li> </ul> </li> <li> <p>3.1.1.2.4. Saubere Fehlerbehandlung     Um \"Information Disclosure\" zu vermeiden, implementiert das Backend eine zweistufige Fehlerbehandlung:</p> <ul> <li>Intern: Technische Details (Stacktraces, SQL-Fehler) werden strukturiert mit dem <code>zap</code>-Logger (Uber) erfasst.</li> <li>Extern: Die API antwortet stets mit generischen HTTP-Statuscodes und Nachrichten (z.B. 500 \"internal server error\", 401 \"invalid credentials\"), die keine R\u00fcckschl\u00fcsse auf die interne Architektur oder den genauen Fehlergrund zulassen.</li> </ul> </li> </ul>"},{"location":"03_Implementierung%20%26%20Anwendungs%E2%80%90Sicherheit/#3113-secret-management","title":"3.1.1.3. Secret-Management","text":"<ul> <li> <p>3.1.1.3.1. Ma\u00dfnahmen zur Secret-Hygiene     Der Quellcode ist frei von hartcodierten Geheimnissen. Alle sensiblen Parameter (Datenbank-Credentials, Redis-URL, Session-Secrets, Master-Encryption-Key) werden zur Laufzeit \u00fcber Umgebungsvariablen (<code>.env</code> Datei oder Container-Environment) mittels <code>godotenv</code> geladen.</p> </li> <li> <p>3.1.1.3.2. Verwaltung von Secrets zur Laufzeit     Die Konfiguration wird beim Start der Anwendung einmalig in eine zentrale <code>Config</code>-Struktur geparst. Der Zugriff auf kritische Schl\u00fcssel (wie den <code>EncryptionKey</code> f\u00fcr MFA) ist auf die Komponenten beschr\u00e4nkt, die diese zwingend ben\u00f6tigen (<code>AuthHandler</code>), und erfolgt rein im Arbeitsspeicher.</p> </li> </ul>"},{"location":"03_Implementierung%20%26%20Anwendungs%E2%80%90Sicherheit/#312-frontend-secure-coding-features","title":"3.1.2. Frontend \u2013 Secure Coding &amp; Features","text":""},{"location":"03_Implementierung%20%26%20Anwendungs%E2%80%90Sicherheit/#3121-schutz-vor-web-angriffen","title":"3.1.2.1. Schutz vor Web-Angriffen","text":"<ul> <li> <p>3.1.2.1.1. Schutzmechanismen gegen XSS     Das Frontend wurde mit React entwickelt. Durch das automatische Escaping von Werten in JSX-Komponenten wird Cross-Site-Scripting (XSS) standardm\u00e4\u00dfig unterbunden. Auf die Nutzung von <code>dangerouslySetInnerHTML</code> wurde im gesamten Projekt verzichtet.</p> </li> <li> <p>3.1.2.1.2. Schutzmechanismen gegen CSRF</p> <ul> <li>Cookie-Attribute: Session-Cookies werden mit dem <code>HttpOnly</code>-Flag gesetzt. Das <code>Secure</code>-Flag ist konfigurierbar (f\u00fcr Produktion vorgesehen).</li> <li>CORS-Policy: Die <code>CORSMiddleware</code> im Backend pr\u00fcft strikt den <code>Origin</code>-Header eingehender Requests gegen eine Whitelist (<code>AllowedOrigins</code>). Credentials (Cookies) werden nur f\u00fcr vertrauensw\u00fcrdige Urspr\u00fcnge akzeptiert (<code>Access-Control-Allow-Credentials: true</code>).</li> </ul> </li> <li> <p>3.1.2.1.3. Content Security Policy (CSP)     In der <code>index.html</code> wird eine strikte CSP via Meta-Tag durchgesetzt:     <code>default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; ...</code>     Dies beschr\u00e4nkt das Laden von Ressourcen (Skripte, Styles, Bilder) ausschlie\u00dflich auf die eigene Origin und verhindert effektiv das Nachladen von Schadcode oder das Exfiltrieren von Daten an fremde Server.</p> </li> </ul>"},{"location":"03_Implementierung%20%26%20Anwendungs%E2%80%90Sicherheit/#3122-daten-und-sitzungssicherheit","title":"3.1.2.2. Daten- und Sitzungssicherheit","text":"<ul> <li> <p>3.1.2.2.1. Sichere Handhabung von Sitzungs- und Authentifizierungsdaten</p> <ul> <li>Storage: Die Session-ID verl\u00e4sst niemals den gesch\u00fctzten <code>HttpOnly</code>-Cookie-Container und ist somit f\u00fcr clientseitiges JavaScript nicht auslesbar.</li> <li>Inaktivit\u00e4ts-Timeout: Der <code>AutoLogoutContext</code> und der Hook <code>useSession.js</code> \u00fcberwachen Benutzerinteraktionen (Mausbewegungen, Tastatureingaben). Nach 15 Minuten Inaktivit\u00e4t wird automatisch der Logout-Prozess angesto\u00dfen, der die Session im Backend invalidiert und lokale States bereinigt.</li> </ul> </li> <li> <p>3.1.2.2.2. API-Kommunikation     Die gesamte Kommunikation zwischen Frontend und Backend ist f\u00fcr die Nutzung \u00fcber HTTPS ausgelegt. Sensible Daten (wie Passw\u00f6rter) werden niemals als URL-Parameter, sondern ausschlie\u00dflich im JSON-Body von POST-Requests \u00fcbertragen.</p> </li> </ul>"},{"location":"03_Implementierung%20%26%20Anwendungs%E2%80%90Sicherheit/#32-erklarung-aller-nicht-sicheren-parts-begrundung","title":"3.2. Erkl\u00e4rung aller nicht-sicheren Parts &amp; Begr\u00fcndung","text":"<ul> <li> <p>Abh\u00e4ngigkeit von Client-Side Encryption (Trust on First Use):</p> <ul> <li>Status: Die Sicherheit der Tresor-Daten steht und f\u00e4llt mit der Integrit\u00e4t des vom Server ausgelieferten JavaScript-Codes (<code>crypto.js</code>).</li> <li>Begr\u00fcndung: Dies ist ein fundamentales architektonisches Risiko webbasierter End-to-End-verschl\u00fcsselter Anwendungen. Ein kompromittierter Server k\u00f6nnte manipulierten Code ausliefern, der das Master-Passwort abgreift. Dieses Risiko wird durch CSP und strikte Server-Sicherheit minimiert, l\u00e4sst sich aber ohne native Client-Applikation nicht vollst\u00e4ndig eliminieren.</li> </ul> </li> <li> <p>Server-Side Encryption Key im Speicher:</p> <ul> <li>Status: Der <code>MasterEncryptionKey</code> zur Entschl\u00fcsselung der MFA-Secrets liegt zur Laufzeit im Arbeitsspeicher des Servers.</li> <li>Begr\u00fcndung: Dies ist notwendig, um die TOTP-Verifizierung durchzuf\u00fchren. Eine sicherere Alternative w\u00e4re der Einsatz eines Hardware Security Modules (HSM) oder eines externen Key Management Services (KMS), was jedoch die Komplexit\u00e4t und Kosten f\u00fcr dieses Projekt unverh\u00e4ltnism\u00e4\u00dfig steigern w\u00fcrde.</li> </ul> </li> <li> <p>Zentrales Session-Management via Redis:</p> <ul> <li>Status: Sessions werden stateful in Redis gespeichert, statt stateless JWTs zu verwenden.</li> <li>Begr\u00fcndung: Dies ist eine bewusste Sicherheitsentscheidung. Stateful Sessions erm\u00f6glichen im Gegensatz zu JWTs eine sofortige Invalidierung (Revocation) bei Sicherheitsvorf\u00e4llen oder Logout. Der minimale Performance-Overhead durch den Redis-Lookup wird zugunsten der h\u00f6heren Sicherheit in Kauf genommen.</li> </ul> </li> </ul>"},{"location":"04_Deployment_CI_CD/","title":"4. Deployment und Reproduzierbarkeit","text":""},{"location":"04_Deployment_CI_CD/#41-erklarung-des-deployment-prozesses","title":"4.1. Erkl\u00e4rung des Deployment-Prozesses","text":""},{"location":"04_Deployment_CI_CD/#411-bestandteile-der-cicd-pipeline","title":"4.1.1. Bestandteile der CI/CD-Pipeline","text":""},{"location":"04_Deployment_CI_CD/#4111-trigger-mechanismus","title":"4.1.1.1 Trigger-Mechanismus","text":"<p>Die CI/CD-Pipeline wird automatisch bei den folgenden Events ausgel\u00f6st:</p> <p> * Push-Events auf die Branches <code>main</code> oder <code>develop</code> * Pull-Request f\u00fcr die Branches <code>main</code> oder <code>develop</code></p> <p>So wird sichergestellt, dass jede Code-\u00c4nderung automatisch getestet und \u00fcberpr\u00fcft wird, bevor sie in die Hauptbranches integriert wird.</p>"},{"location":"04_Deployment_CI_CD/#4112-erstellung-einer-sbom","title":"4.1.1.2 Erstellung einer SBOM","text":"<p>Die SBOM-Generierung erfolgt im Job security-scan:</p> <ul> <li>Tool: Aqua Trivy</li> <li>Format: CycloneDX (Industriestandard)</li> <li>Scan-Umfang: Gesamtes Dateisystem des Repositories</li> <li>Output: evidence/sbom/sbom.cdx.json</li> <li>Speicherung: Als Artifact sbom hochgeladen <p></p> </li> </ul>"},{"location":"04_Deployment_CI_CD/#4113-sast-sca-und-secret-scan","title":"4.1.1.3 SAST, SCA und Secret Scan","text":"<p>SAST (Static Application Security Testing) Mehrschichtige statische Code-Analyse:</p> <p>a) Backend (Go):</p> <ul> <li>golangci-lint: Linter-Sammlung f\u00fcr Go-Code</li> <li>Output: <code>evidence/sast/golangci-lint.xml</code> (Checkstyle-Format)</li> <li>gosec: Security-fokussierter Go-Scanner</li> <li>Output: <code>evidence/sast/gosec-results.sarif</code> <p>b) Frontend (JavaScript):</p> </li> <li>ESLint: JavaScript/TypeScript Linting </li> <li>Output: <code>evidence/sast/frontend-eslint.json</code> <p>c) Multi-Language:</p> </li> <li>CodeQL: Fortgeschrittene semantische Code-Analyse </li> <li>Sprachen: Go und JavaScript</li> <li>Matrix-basierte Ausf\u00fchrung f\u00fcr beide Sprachen</li> <li>Automatisches Upload zu GitHub Security <p>d) Infrastructure as Code:</p> </li> <li>Checkov: Kubernetes-Manifest Scanning </li> <li>Scan-Ziel: <code>infrastructure/</code> Verzeichnis</li> <li>Output: SARIF-Format f\u00fcr Security Tab</li> </ul> <p>SCA (Software Composition Analysis)</p> <p>Schwachstellen-Scanning von Abh\u00e4ngigkeiten:</p> <ul> <li>Trivy Dateisystem-Scan:</li> <li>Scannt alle Abh\u00e4ngigkeiten im Repository</li> <li>Output: <code>evidence/sca/trivy-sca-report.txt</code></li> <li> <p>Quality Gate: Exit-Code 1 bei CRITICAL/HIGH Vulnerabilities</p> </li> <li> <p>Trivy Image-Scans:</p> </li> <li>Backend-Image: <code>evidence/sca/trivy-image-backend.txt</code></li> <li>Frontend-Image: <code>evidence/sca/trivy-image-frontend.txt</code></li> <li>Pr\u00fcft OS- und Library-Schwachstellen</li> <li>Quality Gate: Exit-Code 1 bei CRITICAL/HIGH</li> </ul> <p>Secret Scan</p> <ul> <li>Gitleaks: Durchsucht Git-History nach Secrets</li> <li>Output:  <code>evidence/secrets/gitleaks-report.json</code></li> <li>Features: --verbose: Detaillierte Ausgabe, --redact: Secrets werden unkenntlich gemacht</li> <li>Erkennt: API-Keys, Tokens, Passw\u00f6rter, Private Keys, etc.</li> </ul> <p>Code Quality/Linting: * Backend: <code>golangci-lint</code> f\u00fcr statische Codeanalyse * Frontend: <code>npm run lint</code> f\u00fcr JavaScript/TypeScript</p>"},{"location":"04_Deployment_CI_CD/#4114-build-und-container-build","title":"4.1.1.4 Build und Container-Build","text":"<p>Backend Build:</p> <p> * Build-Stage: Kompilierung des Go-Backends * Runtime-Stage: Schlankes Alpine-Image mit nur dem Binary * Security-Features: Non-root User (<code>appuser</code>), Minimales Base-Image, Healthcheck integriert</p> <p>Frontend Build: </p>"},{"location":"04_Deployment_CI_CD/#4115-image-signing","title":"4.1.1.5 Image Signing","text":"<p>Image-Signierung mit Cosign :</p> <p>Backend Signierung:</p> <p></p> <p>Frontend Signierung:</p> <p></p> <p>Verifizierung:</p> <p>Nach jeder Signierung erfolgt die sofortige Verifikation:</p> <p></p> <p>Vorteile:</p> <ul> <li>Keyless Signing: Nutzt OIDC mit GitHub Actions (id-token:  write)</li> <li>Supply Chain Security: Garantiert Herkunft und Integrit\u00e4t</li> <li>Compliance: Erf\u00fcllt SLSA-Anforderungen</li> <li>Evidence: Logs in <code>evidence/signing/</code> gespeichert</li> </ul>"},{"location":"04_Deployment_CI_CD/#4116-quality-gate-mit-abbruch-bedingungen","title":"4.1.1.6 Quality Gate mit Abbruch-Bedingungen","text":"<p>Die Pipeline implementiert mehrere Quality Gates mit Fail-Fast-Mechanismen:</p> <p>Quality Gate 1: SCA Dateisystem:</p> <p> * Abbruch bei: CRITICAL oder HIGH Schwachstellen in Dependencies * Zeitpunkt: Nach SAST/Secret Scan, vor Build</p> <p>Quality Gate 2: Backend Image:</p> <p> * Abbruch bei: CRITICAL oder HIGH Schwachstellen im Backend-Image * Zeitpunkt: Nach Backend-Build und -Signierung</p> <p>Quality Gate 3: Frontend Image:</p> <p>` * Abbruch bei: CRITICAL oder HIGH Schwachstellen im Frontend-Image * Zeitpunkt: Nach Frontend-Build und -Signierung</p> <p>Strategie: * Nur fixierbare Schwachstellen f\u00fchren zum Abbruch <code>(ignore-unfixed: true)</code> * Severity-Fokus: Nur CRITICAL und HIGH blockieren die Pipeline * Mehrstufig: Checks auf Code-, Dependency- und Image-Ebene</p> <p>Job-Dependencies:  Fehler in fr\u00fcheren Stages verhindern die Ausf\u00fchrung der nachfolgenden Stages.</p>"},{"location":"04_Deployment_CI_CD/#412-kubernetes-security-least-privilege","title":"4.1.2. Kubernetes Security (Least Privilege)","text":"<p>Die Anwendung wird unter strikter Einhaltung des Least-Privilege-Prinzips in Kubernetes betrieben. Dies minimiert die Angriffsfl\u00e4che und begrenzt den Schaden im Falle einer Kompromittierung.</p>"},{"location":"04_Deployment_CI_CD/#4121-namespace-isolierung","title":"4.1.2.1 Namespace-Isolierung","text":"<p>Die gesamte Anwendung l\u00e4uft in einem dedizierten Namespace (<code>pwmanager</code>). Dies sorgt f\u00fcr eine logische Trennung von anderen Cluster-Ressourcen und erm\u00f6glicht granulare Zugriffskontrollen (RBAC) sowie Ressourcen-Quotas.</p>"},{"location":"04_Deployment_CI_CD/#4122-service-account-security","title":"4.1.2.2 Service Account Security","text":"<ul> <li>Automount Service Account Token: Deaktiviert (<code>automountServiceAccountToken: false</code>), wo nicht ben\u00f6tigt.</li> <li>Rechte: Der verwendete Service Account hat keinerlei Cluster-Admin-Rechte und darf nur auf absolut notwendige Ressourcen innerhalb des eigenen Namespaces zugreifen.</li> </ul>"},{"location":"04_Deployment_CI_CD/#4123-pod-security-context","title":"4.1.2.3 Pod Security Context","text":"<p>Die Pods sind so konfiguriert, dass sie mit minimalen Rechten laufen: * Non-Root User: Alle Container laufen als nicht-privilegierter Benutzer (<code>runAsNonRoot: true</code>, <code>runAsUser: 10001</code>). * Read-Only Filesystem: Das Root-Dateisystem ist schreibgesch\u00fctzt (<code>readOnlyRootFilesystem: true</code>), um Manipulationen am System zu verhindern. Tempor\u00e4re Daten werden in <code>emptyDir</code>-Volumes geschrieben. * Capabilities Drop: Alle Linux-Capabilities werden standardm\u00e4\u00dfig verworfen (<code>ALL</code>), und nur explizit ben\u00f6tigte (falls vorhanden) werden hinzugef\u00fcgt. * Privilege Escalation: Die Eskalation von Rechten ist deaktiviert (<code>allowPrivilegeEscalation: false</code>).</p>"},{"location":"04_Deployment_CI_CD/#4124-network-policies","title":"4.1.2.4 Network Policies","text":"<p>Es gilt ein \"Deny-All\"-Standard f\u00fcr eingehenden Verkehr (Ingress). Explizite <code>NetworkPolicies</code> erlauben nur den notwendigen Datenverkehr: * Ingress: Der Ingress-Controller darf sowohl den Frontend- als auch den Backend-Service erreichen. * Frontend -&gt; Backend: Das Frontend darf zus\u00e4tzlich direkt das Backend auf dem definierten Port ansprechen (z.B. f\u00fcr Server-Side Rendering). * Backend -&gt; DB: Das Backend darf nur die Datenbank auf dem Datenbank-Port ansprechen. * Backend -&gt; Redis: Das Backend darf nur den Redis-Cache auf dem Redis-Port ansprechen. * Egress: Aktuell sind keine Einschr\u00e4nkungen f\u00fcr ausgehenden Verkehr definiert (Standard-Allow).</p>"},{"location":"04_Deployment_CI_CD/#42-reproduzierbarkeit","title":"4.2. Reproduzierbarkeit","text":""},{"location":"04_Deployment_CI_CD/#421-frontend-verzeichnis-frontend","title":"4.2.1. Frontend-Verzeichnis (<code>/frontend/</code>)","text":"<pre><code>frontend/\n\u251c\u2500\u2500 public/                                     STATISCHE ASSETS\n\u2502   \u2514\u2500\u2500 index.html                              \u2022 HTML Entry Point\n\u2502\n\u251c\u2500\u2500 src/                                        HAUPTANWENDUNGSCODE\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 components/                             UI-KOMPONENTEN\n\u2502   \u2502   \u251c\u2500\u2500 auth/                               Authentifizierung\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 AuthHeader.jsx                  \u2022 Header f\u00fcr Auth-Seiten\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 AuthLayout.tsx                  \u2022 Layout f\u00fcr Login/Register\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 LoginForm.tsx                   \u2022 Email + Passwort Input\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 RegisterForm.tsx                \u2022 Registrierungs-Formular\n\u2502   \u2502   \u2502\n\u2502   \u2502   \u251c\u2500\u2500 layout/                             Seitenstruktur\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Footer.jsx                      \u2022 App-Footer\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 LayoutWrapper.tsx               \u2022 Haupt-Layout Wrapper\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 Navbar.jsx                      \u2022 Navigationsleiste\n\u2502   \u2502   \u2502\n\u2502   \u2502   \u251c\u2500\u2500 ui/                                 Generische Komponenten\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 AuthButtons.tsx                 \u2022 Login/Logout Buttons\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 ThemeToggle.jsx                 \u2022 Dark/Light Mode\n\u2502   \u2502   \u2502\n\u2502   \u2502   \u251c\u2500\u2500 CreateVaultModal.jsx                \u2022 Tresor erstellen Dialog\n\u2502   \u2502   \u251c\u2500\u2500 MFADisableModal.jsx                 \u2022 MFA deaktivieren Dialog\n\u2502   \u2502   \u251c\u2500\u2500 MFASetupModal.jsx                   \u2022 TOTP Setup Dialog\n\u2502   \u2502   \u251c\u2500\u2500 ProtectedRoute.jsx                  \u2022 Route-Schutz f\u00fcr Auth\n\u2502   \u2502   \u2514\u2500\u2500 VaultEntryModal.jsx                 \u2022 Passwort-Eintrag Dialog\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 context/                                GLOBALER STATE\n\u2502   \u2502   \u2514\u2500\u2500 AutoLogoutContext.jsx               \u2022 Auto-Logout nach 15 Min\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 hooks/                                  CUSTOM LOGIC\n\u2502   \u2502   \u251c\u2500\u2500 useAudit.js                         \u2022 Audit-Logs Daten\n\u2502   \u2502   \u251c\u2500\u2500 useAutoLogout.js                    \u2022 Inaktivit\u00e4ts-Timer\n\u2502   \u2502   \u251c\u2500\u2500 useCrypto.js                        \u2022 AES-256 Verschl\u00fcsselung\n\u2502   \u2502   \u251c\u2500\u2500 useLocalStorage.js                  \u2022 Browser Storage\n\u2502   \u2502   \u251c\u2500\u2500 useMFA.js                           \u2022 MFA Setup/Verify\n\u2502   \u2502   \u251c\u2500\u2500 useSession.js                       \u2022 Session Management\n\u2502   \u2502   \u2514\u2500\u2500 useVault.js                         \u2022 Tresor CRUD\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 pages/                                  SEITEN (ROUTES)\n\u2502   \u2502   \u251c\u2500\u2500 Audit/                              Audit-Logs\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 AuditPage.jsx                   \u2022 Aktions-Historie\n\u2502   \u2502   \u2502\n\u2502   \u2502   \u251c\u2500\u2500 Auth/                               Authentifizierung\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 ForgotPasswordPage.jsx          \u2022 Passwort zur\u00fccksetzen\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 LoginPage.jsx                   \u2022 Login mit Email/Passwort\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 RegisterPage.jsx                \u2022 Neues Konto erstellen\n\u2502   \u2502   \u2502\n\u2502   \u2502   \u251c\u2500\u2500 Dashboard/                          Startseite\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 DashboardPage.jsx               \u2022 \u00dcberblick &amp; Statistiken\n\u2502   \u2502   \u2502\n\u2502   \u2502   \u251c\u2500\u2500 Settings/                           Benutzereinstellungen\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 SettingsPage.jsx                \u2022 Profil, Passwort \u00e4ndern, MFA\n\u2502   \u2502   \u2502\n\u2502   \u2502   \u2514\u2500\u2500 Vault/                              Tresore\n\u2502   \u2502       \u2514\u2500\u2500 VaultPage.jsx                   \u2022 Tresore verwalten\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 services/                               API &amp; LOGIK\n\u2502   \u2502   \u251c\u2500\u2500 api/                                HTTP-Client\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 client.js                       \u2022 Axios Konfiguration\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 endpoints.js                    \u2022 API-URLs\n\u2502   \u2502   \u2502\n\u2502   \u2502   \u2514\u2500\u2500 auth/                               Auth-Services\n\u2502   \u2502       \u2514\u2500\u2500 index.js                        \u2022 Login, Register, etc.\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 types/                                  TYPEN\n\u2502   \u2502   \u2514\u2500\u2500 auth.ts                             \u2022 TypeScript Definitionen\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 utils/                                  HELFER\n\u2502   \u2502   \u251c\u2500\u2500 constants.js                        \u2022 App-Konstanten\n\u2502   \u2502   \u251c\u2500\u2500 crypto.js                           \u2022 AES-256 Functions\n\u2502   \u2502   \u251c\u2500\u2500 errors.js                           \u2022 Error-Handler\n\u2502   \u2502   \u251c\u2500\u2500 formatters.js                       \u2022 Formatierung (Datum, etc)\n\u2502   \u2502   \u251c\u2500\u2500 masterPassword.js                   \u2022 Passwort-Validierung\n\u2502   \u2502   \u251c\u2500\u2500 security.js                         \u2022 XSS, CSRF Protection\n\u2502   \u2502   \u2514\u2500\u2500 validators.js                       \u2022 Input-Validierung\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 App.jsx                                 Root Component\n\u2502   \u251c\u2500\u2500 index.css                               Globale Styles\n\u2502   \u2514\u2500\u2500 main.jsx                                Entry Point\n\u2502\n\u251c\u2500\u2500 .env.local                                  UMGEBUNG (PRIVAT)\n\u251c\u2500\u2500 .env.example                                Env Template\n\u251c\u2500\u2500 .gitignore                                  Git Ignore\n\u251c\u2500\u2500 eslint.config.js                            Code-Qualit\u00e4t\n\u251c\u2500\u2500 index.html                                  HTML Shell\n\u251c\u2500\u2500 package.json                                Dependencies\n\u251c\u2500\u2500 package-lock.json                           Lock File\n\u251c\u2500\u2500 postcss.config.js                           CSS Processing\n\u251c\u2500\u2500 tailwind.config.js                          Tailwind Config\n\u251c\u2500\u2500 vite.config.js                              Build Tool\n\u2514\u2500\u2500 README.md                                   Dokumentation\n</code></pre>"},{"location":"04_Deployment_CI_CD/#422-backend-verzeichnis-backend","title":"4.2.2. Backend-Verzeichnis (<code>/backend/</code>)","text":"<pre><code>backend/\n\u251c\u2500\u2500 cmd/                                        ENTRY POINTS\n\u2502   \u251c\u2500\u2500 api/                                    API Server\n\u2502   \u2502   \u2514\u2500\u2500 main.go                             \u2022 Server Startup (Port 8080)\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 migrate/                                Datenbank Migration\n\u2502       \u2514\u2500\u2500 main.go                             \u2022 Migration Tool (up/down/force)\n\u2502\n\u251c\u2500\u2500 internal/                                   PRIVATE CODE\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 auth/                                   Authentifizierung\n\u2502   \u2502   \u2514\u2500\u2500 session.go                          \u2022 Session Manager + Redis Store\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 config/                                 Konfiguration\n\u2502   \u2502   \u2514\u2500\u2500 config.go                           \u2022 Config Loader + Env Parser\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 handlers/                               HTTP Handler\n\u2502   \u2502   \u251c\u2500\u2500 auth_handler.go                     \u2022 Login, Register, MFA, Password\n\u2502   \u2502   \u251c\u2500\u2500 vault_handler.go                    \u2022 CRUD f\u00fcr Tresore\n\u2502   \u2502   \u251c\u2500\u2500 entry_handler.go                    \u2022 CRUD f\u00fcr Eintr\u00e4ge\n\u2502   \u2502   \u2514\u2500\u2500 audit_handler.go                    \u2022 Audit-Log Endpoints\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 middleware/                             HTTP Middleware\n\u2502   \u2502   \u251c\u2500\u2500 auth.go                             \u2022 JWT/Session Validierung\n\u2502   \u2502   \u251c\u2500\u2500 cors.go                             \u2022 CORS Policy\n\u2502   \u2502   \u2514\u2500\u2500 logging.go                          \u2022 Request/Response Logging\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 models/                                 Datenstrukturen\n\u2502   \u2502   \u251c\u2500\u2500 user.go                             \u2022 User + Auth Models\n\u2502   \u2502   \u251c\u2500\u2500 vault.go                            \u2022 Vault Model\n\u2502   \u2502   \u251c\u2500\u2500 vault_entry.go                      \u2022 Vault Entry Model\n\u2502   \u2502   \u251c\u2500\u2500 mfa.go                              \u2022 MFA + TOTP Models\n\u2502   \u2502   \u2514\u2500\u2500 audit.go                            \u2022 Audit Log Model\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 repository/                             Datenzugriff\n\u2502   \u2502   \u251c\u2500\u2500 user_repo.go                        \u2022 User DB Operations\n\u2502   \u2502   \u251c\u2500\u2500 vault_repo.go                       \u2022 Vault DB Operations\n\u2502   \u2502   \u251c\u2500\u2500 entry_repo.go                       \u2022 Entry DB Operations\n\u2502   \u2502   \u251c\u2500\u2500 mfa_repo.go                         \u2022 MFA DB Operations\n\u2502   \u2502   \u2514\u2500\u2500 audit_repo.go                       \u2022 Audit DB Operations\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 (no direct /internal files)\n\u2502\n\u251c\u2500\u2500 pkg/                                        REUSABLE PACKAGES\n\u2502   \u2514\u2500\u2500 crypto/                                 Verschl\u00fcsselung\n\u2502       \u251c\u2500\u2500 aes.go                              \u2022 AES-256-GCM Encryption\n\u2502       \u2514\u2500\u2500 argon2.go                           \u2022 Argon2id Password Hashing\n\u2502\n\u251c\u2500\u2500 migrations/                                 DATABASE SCHEMA\n\u2502   \u251c\u2500\u2500 000001_create_users.up.sql              \u2022 Users Tabelle\n\u2502   \u251c\u2500\u2500 000001_create_users.down.sql            \u2022 Rollback Users\n\u2502   \u251c\u2500\u2500 000002_create_vaults.up.sql             \u2022 Vaults Tabelle\n\u2502   \u251c\u2500\u2500 000002_create_vaults.down.sql           \u2022 Rollback Vaults\n\u2502   \u251c\u2500\u2500 000003_create_vault_entries.up.sql      \u2022 Vault Entries Tabelle\n\u2502   \u251c\u2500\u2500 000003_create_vault_entries.down.sql    \u2022 Rollback Entries\n\u2502   \u251c\u2500\u2500 000004_create_mfa_secrets.up.sql        \u2022 MFA Secrets Tabelle\n\u2502   \u251c\u2500\u2500 000004_create_mfa_secrets.down.sql      \u2022 Rollback MFA\n\u2502   \u251c\u2500\u2500 000005_create_audit_logs.up.sql         \u2022 Audit Logs Tabelle\n\u2502   \u2514\u2500\u2500 000005_create_audit_logs.down.sql       \u2022 Rollback Audit\n\u2502\n\u251c\u2500\u2500 .env                                        UMGEBUNG (PRIVAT)\n\u251c\u2500\u2500 .env.example                                Env Template\n\u251c\u2500\u2500 go.mod                                      Go Module Definition\n\u251c\u2500\u2500 go.sum                                      Dependency Lock\n\u251c\u2500\u2500 Dockerfile                                  Container Image\n\u251c\u2500\u2500 quickstart.md                               Setup Dokumentation\n\u2514\u2500\u2500 api                                         Compiled Binary (nach build)\n</code></pre>"},{"location":"05_Lessons_Learned/","title":"5. Lessons Learned","text":""},{"location":"05_Lessons_Learned/#positive-lessons-learned","title":"Positive Lessons Learned","text":"<ol> <li>Clientseitige Verschl\u00fcsselung war eine gute Entscheidung</li> </ol> <p>Anfangs stellten wir uns die Frage, wo wir unsere Passw\u00f6rter verschl\u00fcsseln? Auf dem Server oder beim Client? Nach einer kurzen Recherche fanden wir heraus, dass die Entscheidung f\u00fcr clientseitige Verschl\u00fcsselung mit PBKDF2 best practice ist. F\u00fcr einen Passwort Manager ist es essenziell, dass der Server nie das echte Passwort sieht.</p> <ol> <li>Redis f\u00fcr Sessions war eine gute Wahl</li> </ol> <p>PostgreSQL f\u00fcr Benutzerdaten, Redis f\u00fcr Sessions. Diese Trennung hat sich bew\u00e4hrt. Das automatische L\u00f6schen der Session nach 15 Minuten funktioniert einwandfrei. Learning: Manchmal ist die einfache L\u00f6sung die beste.</p> <ol> <li>Docker-Compose macht das Leben leichter</li> </ol> <p>Anfangs hatten wir Probleme mit unterschiedlichen Entwicklungsumgebungen. Mit Docker-Compose klappt das Setup jetzt bei jedem auf Anhieb.</p>"},{"location":"05_Lessons_Learned/#negative-lessons-learned","title":"Negative Lessons Learned","text":"<ol> <li>Zero-Knowledge ist komplizierter als gedacht</li> </ol> <p>Die Theorie klingt einfach, aber die Implementierung hat uns einige Kopfschmerzen bereitet. Besonders der Ablauf: Salt vom Server holen \u2192 Client-seitig hashen \u2192 Login Es hat eine Weile gedauert, bis alles richtig funktioniert hat.</p> <ol> <li>Balance zwischen Sicherheit und Benutzerfreundlichkeit</li> </ol> <p>Zu kurze Session-Timeouts nerven Benutzer. Zu lange Session-Timeouts sind unsicher. Kompromiss: 15 Minuten sind okay, aber in der Zukunft w\u00fcrden wir vielleicht \"Remember Me\" hinzuf\u00fcgen.</p> <ol> <li>Argon2 vs. PBKDF2</li> </ol> <p>Anfangs waren wir verwirrt, Warum zwei verschiedene Hashing-Verfahren verwendet werden sollten? Nach einer Recherche war uns klar, dass der Client (PBKDF2) und Server (Argon2) verwendet.</p>"},{"location":"05_Lessons_Learned/#was-wir-beim-nachsten-mal-anders-machen-wurden","title":"Was wir beim n\u00e4chsten Mal anders machen w\u00fcrden","text":"<ol> <li>Fr\u00fcher mit Security-Testing anfangen</li> </ol> <p>Wir haben erst sp\u00e4t mit Security-Reviews begonnen. Beim n\u00e4chsten Projekt w\u00fcrden wir von Anfang an Threat Modeling machen. Lesson: Sicherheit nachtr\u00e4glich einbauen ist 10x schwieriger.</p> <ol> <li>Besseres Error-Handling im Frontend</li> </ol> <p>Wenn die Salt-Abfrage fehlschl\u00e4gt, bekommt der User manchmal kryptische Fehlermeldungen. Das Frontend-Error-Handling k\u00f6nnte benutzerfreundlicher sein.</p> <ol> <li>Dokumentation w\u00e4hrend der Entwicklung schreiben</li> </ol> <p>Wir haben erst viel am Ende dokumentiert. N\u00e4chstes Mal wird es besser sein das Wiki parallel zur Entwicklung zu pflegen.</p> <ol> <li>Automatisches L\u00f6schen der Zwischenablage</li> </ol> <p>Dieses Feature war deutlich schwerer zu implementieren als anfangs gedacht, da es ein Systemprozess ist auf den nicht direkt vom Browser aus zugegriffen werden kann. Wir mussten also einen Workaround implementieren.</p> <ol> <li>Golang f\u00fcr Backend war eine gute Entscheidung</li> </ol> <p>Starke Typisierung hilft, Fehler fr\u00fch zu finden. Die crypto-Packages sind robust und gut dokumentiert. React im Frontend erm\u00f6glicht moderne UX.</p>"},{"location":"K3S_SETUP/","title":"K3s Setup &amp; Deployment Guide","text":"<p>Diese Anleitung beschreibt die Installation von K3s und das Deployment des Password Managers unter Verwendung der bereitgestellten Automatisierungsskripte (<code>Makefile</code>).</p>"},{"location":"K3S_SETUP/#1-k3s-installation","title":"1. K3s Installation","text":"<p>Falls noch kein K3s Cluster vorhanden ist, kann es mit folgenden Befehl installiert werden:</p> <pre><code>curl -sfL https://get.k3s.io | sh -\n</code></pre> <p>Hinweis: Nach der Installation ist die Kubeconfig unter <code>/etc/rancher/k3s/k3s.yaml</code> zu finden. Der User braucht Leserechte auf diese Datei oder man verwendet <code>sudo</code>.</p> <p>\u00dcberpr\u00fcfen der Installation: <pre><code>sudo kubectl get nodes\n</code></pre></p>"},{"location":"K3S_SETUP/#2-projekt-setup","title":"2. Projekt Setup","text":"<p>Das Projekt enth\u00e4lt ein <code>Makefile</code>, das den gesamten Build- und Deployment-Prozess automatisiert.</p>"},{"location":"K3S_SETUP/#voraussetzungen","title":"Voraussetzungen","text":"<ul> <li><code>docker</code></li> <li><code>make</code></li> <li><code>kubectl</code></li> <li><code>openssl</code> (f\u00fcr die Zertifikats- und Secret-Generierung)</li> </ul>"},{"location":"K3S_SETUP/#optional-docker-images-lokal-bauen","title":"(OPTIONAL Docker Images lokal bauen)","text":"<p>Deployment des Cluster mit lokal gebauten Images:</p> <pre><code>sudo make setup-local\n</code></pre>"},{"location":"K3S_SETUP/#deployment-setup","title":"Deployment (Setup)","text":"<p>Deployment mit Images aus der Github Container Registry.</p> <p>Der <code>setup</code> Befehl f\u00fchrt folgende Aktionen automatisch aus: 1.  L\u00f6scht einen existierenden <code>pwmanager</code> Namespace (Clean Install). 2.  L\u00e4dt Frontend und Backend Image von der Github Registry herunter.  3.  Generiert automatisch sichere, zuf\u00e4llige Secrets f\u00fcr:     *   Datenbank-Passwort     *   Session-Secret     *   Master Encryption Key 4.  Erstellt eine eigene Certificate Authority (CA) und Server-Zertifikate f\u00fcr TLS. (Falls nicht vorhanden, bei erneutem Ausf\u00fchren wird die vorher erstelle CA verwendet) 5.  Erstellt das Kubernetes TLS Secret. 6.  Wendet alle Manifeste an und startet die Pods.</p> <p>Setup ausf\u00fchren:</p> <pre><code>make setup\n</code></pre>"},{"location":"K3S_SETUP/#3-zugriff-auf-die-anwendung","title":"3. Zugriff auf die Anwendung","text":"<p>Nachdem das Setup durchgelaufen ist, ist die Anwendung \u00fcber den Ingress Controller erreichbar.</p> <ol> <li> <p>IP-Adresse ermitteln: <pre><code>ip addr show eth0\n# oder einfach localhost versuchen\n</code></pre></p> </li> <li> <p>Browser \u00f6ffnen:</p> <ul> <li>Frontend: <code>https://&lt;IHRE-IP&gt;/</code></li> <li>Backend API: <code>https://&lt;IHRE-IP&gt;/api/</code></li> </ul> </li> <li> <p>Zertifikat importieren (Optional):     Da eine eigene CA verwendet wird, zeigt der Browser eine Warnung (\"Nicht sicher\").</p> <ul> <li>Das Root-Zertifikat liegt unter <code>CertificateAuthority/rootCA.pem</code>.</li> <li>Das Zertifikat kann im Browser oder Betriebssystem importiert werden, um der Verbindung zu vertrauen.</li> </ul> </li> </ol>"},{"location":"K3S_SETUP/#4-verwaltung","title":"4. Verwaltung","text":"<p>Logs ansehen: <pre><code># Backend Logs\nkubectl logs -l app=backend -n pwmanager -c backend\n\n# Datenbank Migration Logs\nkubectl logs -l app=backend -n pwmanager -c migrate\n</code></pre></p> <p>Alles l\u00f6schen (Teardown): <pre><code>make teardown\n</code></pre></p>"},{"location":"SecurityRequirements/","title":"Security Requirements","text":"<p>Projekt: Passwort Manager Version: 2.0 Stand: 14. Dezember 2025</p>"},{"location":"SecurityRequirements/#ubersicht","title":"\u00dcbersicht","text":"<p>Dieses Dokument definiert die verbindlichen Sicherheitsanforderungen f\u00fcr den Passwort-Manager. Alle Anforderungen sind als MUSS-Kriterien zu verstehen und m\u00fcssen in der Implementierung vollst\u00e4ndig erf\u00fcllt werden.</p> <p>Die Anforderungen basieren auf dem STRIDE-Bedrohungsmodell und adressieren folgende Bedrohungskategorien: - S - Spoofing (Identit\u00e4tsf\u00e4lschung) - T - Tampering (Manipulation) - R - Repudiation (Nicht-Abstreitbarkeit) - I - Information Disclosure (Informationsoffenlegung) - D - Denial of Service (Dienstverweigerung) - E - Elevation of Privilege (Rechteausweitung)</p>"},{"location":"SecurityRequirements/#sr-1-verschlusselung-der-secrets-at-rest","title":"SR-1: Verschl\u00fcsselung der Secrets at Rest","text":""},{"location":"SecurityRequirements/#anforderung","title":"Anforderung","text":"<p>Alle gespeicherten Secrets (Passw\u00f6rter, API-Keys) M\u00dcSSEN in der Datenbank mit AES-256-GCM verschl\u00fcsselt werden. </p> <p>Der Encryption-Key darf NICHT im Code oder in der Datenbank selbst gespeichert sein, sondern MUSS aus dem User-Master-Password abgeleitet werden (z.B. via PBKDF2 mit mindestens 100.000 Iterationen).</p>"},{"location":"SecurityRequirements/#technische-details","title":"Technische Details","text":"Parameter Spezifikation Verschl\u00fcsselungsalgorithmus AES-256-GCM Key-Derivation-Funktion PBKDF2 Minimale Iterationen 100.000 Salt Unique per Vault, mindestens 32 Bytes Key-Speicherung Niemals im Code oder in der Datenbank"},{"location":"SecurityRequirements/#begrundung","title":"Begr\u00fcndung","text":"<p>Schutz vor Information Disclosure bei DB-Compromise.</p> <p>STRIDE-Kategorie: I (Information Disclosure)</p>"},{"location":"SecurityRequirements/#validierung","title":"Validierung","text":"<ul> <li>[ ] Verschl\u00fcsselungsalgorithmus ist AES-256-GCM</li> <li>[ ] Key-Derivation verwendet PBKDF2 mit \u2265100.000 Iterationen</li> <li>[ ] Keys werden niemals persistent gespeichert</li> <li>[ ] Jeder Vault hat einen eindeutigen Salt</li> </ul>"},{"location":"SecurityRequirements/#sr-2-sicheres-password-hashing","title":"SR-2: Sicheres Password-Hashing","text":""},{"location":"SecurityRequirements/#anforderung_1","title":"Anforderung","text":"<p>Alle Benutzerpassw\u00f6rter M\u00dcSSEN serverseitig mit dem Argon2id Algorithmus gehasht werden. </p> <p>Es MUSS f\u00fcr jeden Benutzer ein zuf\u00e4lliger, eindeutiger Salt (mindestens 16 Bytes) generiert werden.</p>"},{"location":"SecurityRequirements/#technische-details_1","title":"Technische Details","text":"Parameter Spezifikation Algorithmus Argon2id Memory 64 MB (65536 KB) Iterationen 3 Parallelismus 4 Threads Salt-L\u00e4nge 16 Bytes Key-L\u00e4nge 32 Bytes"},{"location":"SecurityRequirements/#begrundung_1","title":"Begr\u00fcndung","text":"<p>Schutz vor Brute-Force-Angriffen und Rainbow-Table-Attacken auf die Passwort-Datenbank.</p> <p>STRIDE-Kategorien: I (Information Disclosure), S (Spoofing)</p>"},{"location":"SecurityRequirements/#validierung_1","title":"Validierung","text":"<ul> <li>[ ] Algorithmus ist Argon2id</li> <li>[ ] Parameter entsprechen den Sicherheitsstandards (OWASP Empfehlung)</li> <li>[ ] Salt ist zuf\u00e4llig und eindeutig pro User</li> </ul>"},{"location":"SecurityRequirements/#sr-3-zero-knowledge-architektur-fur-secrets","title":"SR-3: Zero-Knowledge-Architektur f\u00fcr Secrets","text":""},{"location":"SecurityRequirements/#anforderung_2","title":"Anforderung","text":"<p>Der Backend-Server darf zu KEINEM Zeitpunkt Zugriff auf entschl\u00fcsselte Secrets haben. </p> <p>Verschl\u00fcsselung und Entschl\u00fcsselung M\u00dcSSEN clientseitig (im Frontend) mit dem vom User-Password abgeleiteten Key erfolgen. Der Server speichert ausschlie\u00dflich verschl\u00fcsselte Blobs.</p>"},{"location":"SecurityRequirements/#technische-details_2","title":"Technische Details","text":"Komponente Verantwortung Client (Browser) Key-Derivation, Ver-/Entschl\u00fcsselung Backend Speicherung verschl\u00fcsselter Blobs Datenbank Persistierung verschl\u00fcsselter Daten"},{"location":"SecurityRequirements/#architektur-prinzipien","title":"Architektur-Prinzipien","text":"<ol> <li>Master-Passwort verl\u00e4sst niemals den Browser</li> <li>Verschl\u00fcsselungs-Keys werden nur im Browser-Memory gehalten</li> <li>Server verarbeitet nur verschl\u00fcsselte Daten</li> <li>API-Endpoints akzeptieren ausschlie\u00dflich verschl\u00fcsselte Payloads</li> </ol>"},{"location":"SecurityRequirements/#begrundung_2","title":"Begr\u00fcndung","text":"<p>Minimierung der Angriffsfl\u00e4che, Schutz bei Backend-Compromise.</p> <p>STRIDE-Kategorie: I (Information Disclosure)</p>"},{"location":"SecurityRequirements/#validierung_2","title":"Validierung","text":"<ul> <li>[ ] Crypto-Operationen erfolgen ausschlie\u00dflich im Frontend</li> <li>[ ] Backend-Code enth\u00e4lt keine Entschl\u00fcsselungslogik</li> <li>[ ] API-Endpoints verarbeiten nur verschl\u00fcsselte Daten</li> </ul>"},{"location":"SecurityRequirements/#sr-4-sichere-session-verwaltung-mit-automatischer-timeout","title":"SR-4: Sichere Session-Verwaltung mit automatischer Timeout","text":""},{"location":"SecurityRequirements/#anforderung_3","title":"Anforderung","text":"<p>Sessions M\u00dcSSEN nach 15 Minuten Inaktivit\u00e4t automatisch invalidiert werden. </p> <p>Session-Tokens M\u00dcSSEN als httpOnly, Secure, SameSite=Strict Cookies implementiert werden und d\u00fcrfen NICHT in localStorage gespeichert werden. </p> <p>Nach Logout MUSS das Session-Token serverseitig sofort revoked werden.</p>"},{"location":"SecurityRequirements/#technische-details_3","title":"Technische Details","text":"Parameter Spezifikation Cookie-Flags <code>httpOnly; Secure; SameSite=Strict</code> Inaktivit\u00e4ts-Timeout 15 Minuten Token-Storage Ausschlie\u00dflich in Cookies (kein localStorage) Session-Revocation Sofort bei Logout Backend-Storage Redis mit TTL"},{"location":"SecurityRequirements/#session-lifecycle","title":"Session-Lifecycle","text":"<pre><code>1. Login \u2192 Token-Generierung \u2192 Redis (TTL: 15 Min)\n2. Request \u2192 Token-Validierung \u2192 TTL-Refresh\n3. 15 Min Inaktivit\u00e4t \u2192 Token-Expiry \u2192 Auto-Logout\n4. Logout \u2192 Token-Revocation \u2192 Redis-Delete\n</code></pre>"},{"location":"SecurityRequirements/#begrundung_3","title":"Begr\u00fcndung","text":"<p>Schutz vor Session-Hijacking und XSS-Angriffen.</p> <p>STRIDE-Kategorien: S (Spoofing), E (Elevation of Privilege)</p>"},{"location":"SecurityRequirements/#validierung_3","title":"Validierung","text":"<ul> <li>[ ] Cookies haben httpOnly, Secure, SameSite=Strict Flags</li> <li>[ ] Inaktivit\u00e4ts-Timeout ist auf 15 Minuten konfiguriert</li> <li>[ ] localStorage wird nicht f\u00fcr Session-Token verwendet</li> <li>[ ] Logout invalidiert Token serverseitig in Redis</li> </ul>"},{"location":"SecurityRequirements/#sr-5-audit-logging-aller-sicherheitskritischen-aktionen","title":"SR-5: Audit-Logging aller sicherheitskritischen Aktionen","text":""},{"location":"SecurityRequirements/#anforderung_4","title":"Anforderung","text":"<p>Folgende Aktionen M\u00dcSSEN unver\u00e4nderbar geloggt werden:</p> <ul> <li>Login (Erfolg/Fehlgeschlagen)</li> <li>Secret-Zugriff (Lesen/Erstellen/L\u00f6schen)</li> <li>MFA-\u00c4nderungen</li> <li>Master-Password-\u00c4nderungen</li> </ul> <p>Logs M\u00dcSSEN folgende Informationen enthalten: - User-ID - Timestamp - IP-Adresse - Action-Type</p> <p>Logs d\u00fcrfen NIEMALS entschl\u00fcsselte Secrets oder Passw\u00f6rter enthalten.</p>"},{"location":"SecurityRequirements/#technische-details_4","title":"Technische Details","text":""},{"location":"SecurityRequirements/#log-format","title":"Log-Format","text":"Feld Typ Beschreibung <code>log_id</code> UUID Eindeutiger Log-Eintrag-Identifier <code>user_id</code> UUID Referenz auf User <code>action</code> String Typ der Aktion (siehe unten) <code>ip_address</code> String IPv4/IPv6 Adresse <code>user_agent</code> String Browser/Client Information <code>timestamp</code> DateTime ISO 8601 Format (UTC) <code>status</code> String SUCCESS / FAILURE <code>metadata</code> JSON Zus\u00e4tzliche Informationen (optional)"},{"location":"SecurityRequirements/#action-types","title":"Action-Types","text":"<pre><code>AUTH_LOGIN_SUCCESS\nAUTH_LOGIN_FAILURE\nAUTH_LOGOUT\nSECRET_CREATE\nSECRET_READ\nSECRET_UPDATE\nSECRET_DELETE\nMFA_ENABLE\nMFA_DISABLE\nPASSWORD_CHANGE\nVAULT_CREATE\nVAULT_DELETE\n</code></pre>"},{"location":"SecurityRequirements/#verbotene-inhalte-in-logs","title":"Verbotene Inhalte in Logs","text":"<ul> <li>Entschl\u00fcsselte Passw\u00f6rter</li> <li>Master-Passw\u00f6rter</li> <li>Verschl\u00fcsselungs-Keys</li> <li>Session-Tokens (in Plaintext)</li> <li>MFA-Secrets</li> </ul>"},{"location":"SecurityRequirements/#begrundung_4","title":"Begr\u00fcndung","text":"<p>Non-Repudiation, Incident Response, Compliance.</p> <p>STRIDE-Kategorie: R (Repudiation)</p>"},{"location":"SecurityRequirements/#validierung_4","title":"Validierung","text":"<ul> <li>[ ] Audit-Logging ist f\u00fcr alle definierten Aktionen implementiert</li> <li>[ ] Log-Eintr\u00e4ge sind unver\u00e4nderbar (Append-Only)</li> <li>[ ] Logs enthalten alle erforderlichen Felder</li> <li>[ ] Keine sensiblen Daten in Logs vorhanden</li> <li>[ ] Log-Retention ist konfiguriert (mindestens 90 Tage)</li> </ul>"},{"location":"SecurityRequirements/#compliance-matrix","title":"Compliance Matrix","text":"Requirement STRIDE Kritikalit\u00e4t Implementierungsstatus SR-1 I Kritisch Implementiert SR-2 I, S Kritisch Implementiert SR-3 I Kritisch Implementiert SR-4 S, E Hoch Teilweise umgesetzt SR-5 R Hoch Implementiert <p>Legende: - Offen - In Bearbeitung - Implementiert - Validiert</p>"},{"location":"SecurityRequirements/#review-updates","title":"Review &amp; Updates","text":"Version Datum \u00c4nderungen Autor 1.0 Oktober 2025 Initiale Version Projektteam"},{"location":"SecurityRequirements/#anhang-referenzen","title":"Anhang: Referenzen","text":"<ul> <li>STRIDE-Modell: Microsoft Threat Modeling</li> <li>OWASP Top 10: https://owasp.org/www-project-top-ten/</li> <li>NIST Cryptographic Standards: https://csrc.nist.gov/publications</li> <li>TLS Best Practices: https://wiki.mozilla.org/Security/Server_Side_TLS</li> </ul>"}]}